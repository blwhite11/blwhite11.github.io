[["index.html", "1 Introduction 1.1 Description of the R programming block 1.2 Contents of the R programming block 1.3 Evaluation", " 1 Introduction 1.1 Description of the R programming block In this block of the Bioinformatic’s subject, the student will learn how to become a proficient in programming and how to use for effective omics data analysis. The course will cover practical issues in how to improve: the scripting code, generating appropriate documents, managing data, learning techniques associated with optimizing scripts for eventually developing R packages. 1.2 Contents of the R programming block Introduction and R Basics - (01/10/25) - Patricia Genius Serra Data management and Visualization - (08/10/25) - Blanca Rodríguez Fernández Basic Functions and Programming - (15/10/25) - Blanca Rodríguez Fernández Advanced Functions and Efficient Programming - (22/10/25) - Blanca Rodríguez Fernández Dynamic Report Generation - (29/10/25) - Patricia Genius Serra Ggplot2 R package: data visualization - (05/11/25) - Patricia Genius Serra Final activity - (12/11/25) - Patricia Genius Serra 1.3 Evaluation 10% Weekly exercise 30% Practical Teachers: Blanca Rodríguez Fernández brodriguez@barcelonabeta.org blancarf1995@gmail.com Patricia Genius Serra pgenius@barcelonabeta.org "],["section-1.-errors-you-may-find-in-r.html", "2 SECTION 1. Errors you may find in R 2.1 Installing R 2.2 Loading packages 2.3 Defining directories 2.4 Resources you have", " 2 SECTION 1. Errors you may find in R 2.1 Installing R Missing R installation - Before installing Rstudio, we have to install R, as Rstudio is an integrated development environment for R. Permission denied while installing packages - We must run R/Rstudio (.exe file) as an administrator or install packages in a directory where we have write permissions (Usually packages are saved in the following directory “C:/Program Files/R/R-versionXXXXX”) We need to allow the installer to make changes in our device - the installer will have the necessary administrative privileges to write files to system directories. Errors related to missing system dependencies - We have to install the necessary system dependencies. Disk space issues - We have to remove unnecessary files or applications to free up space in our disk space. 2.2 Loading packages “ERROR: this R is version 3.1.2, package ‘XXXXXXXXXX’ requires R &gt;= 3.2.3.” - We probably need to download the latest version for R (update R). How to proceed: Download the latest version of R, for Windows, from CRAN at : https://cran.r-project.org/bin/windows/base/ From the tab “Packages” in RStudio, update the libraries. 2.3 Defining directories “Warning: cannot open file ‘C:/Users/pathtothefile/file.txt’: No such file or directory Error in file(file,”rt”) : cannot open the connection” We have to be careful, is not the same defining the path for windows than for mac. We can check how our system defines the path to a working directory by typing getwd(). Usually in windows we define a path as “C:/Users/pathtothefile” and in mac as “/Users/pathtothefile”. Issues with long file paths exceeding system limits - We have to shorten the file/directory names. Error in file(file, “rt”) : cannot open the connection - Issues with paths containing spaces - We can enclose paths with spaces in double quotes. Example: “C:/XXX/Program Files/R/” - “C:/XXX/”Program Files”/R/” 2.4 Resources you have Online forums and communities we can check for help: Stack Overflow, R-bloggers Cheatsheets - Posit Rstudio Cheatsheet Updates Other "],["section-2.-introduction-to-r.html", "3 SECTION 2. Introduction to R 3.1 Why R? 3.2 Creating a new project directory in RStudio 3.3 RStudio Interface 3.4 Organizing your working directory &amp; setting up 3.5 Simple computations with R 3.6 Math functions 3.7 Variable Assignment 3.8 Data types 3.9 Create new data 3.10 Structures 3.11 The environment 3.12 Using scripts 3.13 R basic base functions 3.14 Reading and writing data files 3.15 Libraries/Packages 3.16 Help and documentation 3.17 Interesting references: 3.18 Exercises", " 3 SECTION 2. Introduction to R 3.1 Why R? R has a number of advantages compared to other statistical software tools (i.e. SAS, SPSS, Stata, etc …). Open-source (It is free!!!) Cross-platform (Windows, Mac, Linux) Updated regularly Extremely flexible and can do or be made to do joust about anything Amazing graphical capabilities 3.2 Creating a new project directory in RStudio Let’s create a new project directory for our “Introduction to R” lesson today. Open RStudio Go to the File menu and select New Project. In the New Project window, choose New Directory. Then, choose Empty Project. Name your new directory Intro-to-R and then “Create the project as subdirectory of:” the Desktop (or location of your choice). Click on Create Project. After your project is completed, if the project does not automatically open in RStudio, then go to the File menu, select Open Project, and choose Intro-to-R.Rproj. When RStudio opens, you will see three panels in the window. Go to the File menu and select New File, and select R Script. 3.3 RStudio Interface The RStudio interface has four main panels: Console: where you can type commands and see output. The console is all you would see if you ran R in the command line without RStudio. Script editor: where you can type out commands and save to file. You can also submit the commands to run in the console. Environment/History: environment shows all active objects and history keeps track of all commands run in console Files/Plots/Packages/Help 3.4 Organizing your working directory &amp; setting up 3.4.1 Viewing your working directory Before we organize our working directory, let’s check to see where our current working directory is located by typing into the console: getwd() If you wanted to choose a different directory to be your working directory, you could navigate to a different folder in the Files tab, then, click on the More dropdown menu and select Set As Working Directoryor typing into the console: setwd(path) 3.4.2 Console command prompt Interpreting the command prompt can help understand when R is ready to accept commands. Below lists the different states of the command prompt and how you can exit a command: Console is ready to accept commands: &gt;. If R is ready to accept commands, the R console shows a &gt; prompt. When the console receives a command (by directly typing into the console or running from the script editor (Ctrl-Enter), R will try to execute it. After running, the console will show the results and come back with a new &gt; prompt to wait for new commands. Console is waiting for you to enter more data: +. If R is still waiting for you to enter more data because it isn’t complete yet, the console will show a + prompt. It means that you haven’t finished entering a complete command. Often this can be due to you having not ‘closed’ a parenthesis or quotation. Escaping a command and getting a new prompt: esc If you’re in Rstudio and you can’t figure out why your command isn’t running, you can click inside the console window and press esc to escape the command and bring back a new prompt &gt;. 3.5 Simple computations with R R can be used as a calculator. You can just type your equation and execute the command: 2+2 1+2*3-4/5 (19465*0.25)^23 5%%2 Example: Addition of two values 3 + 6 ## [1] 9 # The output is always preceded by a number between brackets: [1] 3.6 Math functions log(x) Natural log. sum(x) Sum. exp(x) Exponential. mean(x) Mean. max(x) Largest element. median(x) Median. min(x) Smallest element. quantile(x) Percentage quantiles. round(x, n) Round to n decimal places. rank(x) Rank of elements. var(x) The variance. cor(x,y) Correlation. sd(x) The standard deviation. 3.7 Variable Assignment You can assign a number to a name. x &lt;- 3 Now “x” is called a variable and it appears in the workspace window, which means that R stores the value of “x” in its memory and it can be used later. In general, by using the &lt;-, you can assign a value to an object If you type the name of a variable, the current value of the variable will be printed x ## [1] 3 There are variables that are already defined in R, like variable “pi” pi ## [1] 3.141593 Calculating the perimeter of the circumference with radius 3 2 * pi * x ## [1] 18.84956 Changing the value of radius and reusing the code x &lt;- 5 2 * pi * x ## [1] 31.41593 Remarks R is case sensitive A &lt;- 33 a &lt;- 44 A ## [1] 33 a ## [1] 44 The tag # indicates a comment 3.8 Data types Numeric data: 1, 2, 3 x &lt;- c(1, 2, 3); x ## [1] 1 2 3 is.numeric(x) ## [1] TRUE class(x) ## [1] &quot;numeric&quot; Character data: “a”, “b”, “c” x &lt;- c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;); x ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; is.character(x) ## [1] TRUE Logical data x &lt;- 1:10 &lt; 5 x ## [1] TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE FALSE !x ## [1] FALSE FALSE FALSE FALSE TRUE TRUE TRUE TRUE TRUE TRUE which(x) # Returns index for the &#39;TRUE&#39; values in logical vector ## [1] 1 2 3 4 Factor : Character strings with preset levels. (Needed for some statistical models). factor(c(&quot;1&quot;, &quot;0&quot;, &quot;1&quot;, &quot;0&quot;, &quot;1&quot;)) ## [1] 1 0 1 0 1 ## Levels: 0 1 3.9 Create new data Using functions as seq, rep and sample we can generate new information. seq(10,80, 2) ## [1] 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52 54 56 58 ## [26] 60 62 64 66 68 70 72 74 76 78 80 rep(c(&quot;A&quot;,&quot;B&quot;), 2); rep(c(&quot;A&quot;,&quot;B&quot;), each=2) ## [1] &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;B&quot; ## [1] &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;B&quot; sample(seq(10,80, 2),5) ## [1] 66 56 70 64 74 3.10 Structures Vectors (1D) myVec &lt;- 1:10; names(myVec) &lt;- letters[1:10] #Subsetting by index/position numbers myVec[1:5] ## a b c d e ## 1 2 3 4 5 myVec[c(2,4,6,8)] ## b d f h ## 2 4 6 8 # Subsetting by field names myVec[c(&quot;b&quot;, &quot;d&quot;, &quot;f&quot;)] ## b d f ## 2 4 6 #Subsetting by same length logical vectors myLog &lt;- myVec &gt; 10 ##Generating new vectors vec1&lt;-seq(10,20,5) vec2&lt;- (1:9) vec3&lt;- c(vec1, vec2) ##combining information x&lt;-&quot;Hello&quot; paste0(x,&quot;World&quot;) ## [1] &quot;HelloWorld&quot; paste(x,&quot;World&quot;, sep=&quot; &quot;) ## [1] &quot;Hello World&quot; Matrices (2D): two dimensional structures with data of same type myMA &lt;- matrix(1:30, 3, 10, byrow = TRUE) class(myMA) ## [1] &quot;matrix&quot; &quot;array&quot; # Subsetting by rows: myMA[1:2,] ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] ## [1,] 1 2 3 4 5 6 7 8 9 10 ## [2,] 11 12 13 14 15 16 17 18 19 20 Data Frames (2D): two dimensional structures with variable data types myDF &lt;- data.frame(Col1=1:10, Col2=10:1) # Subsetting by rows: myDF[1:2, ] ## Col1 Col2 ## 1 1 10 ## 2 2 9 # Subsetting by field names myDF$Col1 ## [1] 1 2 3 4 5 6 7 8 9 10 Lists: containers for any object type myL &lt;- list(name=&quot;Fred&quot;, wife=&quot;Mary&quot;, no.children=3, child.ages=c(4,7,9)) myL ## $name ## [1] &quot;Fred&quot; ## ## $wife ## [1] &quot;Mary&quot; ## ## $no.children ## [1] 3 ## ## $child.ages ## [1] 4 7 9 myL[[4]][1:2] ## [1] 4 7 3.11 The environment ls() List all variables in the environment. rm(x) Remove x from the environment. rm(list = ls()) Remove all variables from the environment. Remarks You can use the environment panel in RStudio to browse variables in your environment. 3.12 Using scripts However, instead of working directly on the R console it is usually more convenient to use R scripts. An R script is a text file where you can type the commands that you want to execute in R. Scripts have file names with the extension .R, for instance, “myscript.R”. The R script is where you keep a record of your work. Using R scripts is very convenient because all R commands used in a session are saved in the script file and can be executed again in a future session. To create a new R script go to File -&gt; New -&gt; R Script To open an existing R script go to File -&gt; Open -&gt; R Script-&gt;select your script If you want to run a line from the script window, you place the cursor in any place of the line and click Run or press CTRL+ENTER if you are using Windows/Linux or Command+Enter if you are using MAC. You can execute part of a script (or the whole script) by selecting the corresponding lines and pressing Run or CTRL+ENTER or Command+Enter. You can also execute the whole script by using the R function source( ) source(&quot;scriptname.R&quot;) Read Section 5 “Scripts” from document “A (very) short introduction to R” by P. Torfs and C. Brauer 3.13 R basic base functions Usual tasks in R involve functions. R comes with a slew of pre-installed functions. These functions are installed as part of the base package which is located in your ‘’library’ directory. An R function is used by typing its name followed by its arguments (also called parameters) between parentheses. Example: seq( ) is a function for generating a sequence of numbers. Its arguments are arg1=from, which specifies the first number of the sequence, arg2= to, last number of the the sequence, and arg3=by, the increment of the sequence. seq(10,80, 2) # generates a sequence from 10 to 20 with increment 2 ## [1] 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52 54 56 58 ## [26] 60 62 64 66 68 70 72 74 76 78 80 The number between brackets at the beginning of each line of the output indicates the position of the first element of each row: 10 is the first element of the output and 56 is the 24th element of the output. R treats all functions like ‘objects’. All functions have names and take arguments in parentheses: ‘function()’ For example, complex operations often requires an input and gives and output. This is done with the function ‘print()’. print(&quot;Hello world&quot;) print(exp) 3.14 Reading and writing data files read.table( ): this function reads a text data file and stores the values into a data frame header=T : first row of the data file contains the names of the columns or variables sep=\"\" : the values of each row are separated by a space sep=\"\\t\" : the values of each row are separated by a tabulation sep=\",\" : the values of each row are separated by a comma dec=\".\": the decimal symbol is a point Example example &lt;- read.table(&quot;treatment.txt&quot;, header=F, sep=&quot;&quot;) # This instruction reads file &quot;treatment.txt&quot; and creates the dataframe &quot;example&quot; write.table( ): this function writes a data frame into a text file Example write.table(treatment, file=&quot;treatment.txt&quot;, row.names=FALSE) # This instruction writes the dataframe &quot;treatment&quot; in file &quot;treatment.txt&quot; # row.names=FALSE prevents R for printint the names of the rows (or just the row numbers) in the output file 3.15 Libraries/Packages R comes with a standard set of packages. Others are available for download and installation. Standard packages: The standard (or base) packages are considered part of the R source code. They contain the basic functions that allow R to work, and the datasets and standard statistical and graphical functions. They should be automatically available in any R installation. Contributed packages: There are thousands of contributed packages for R, written by many different authors. Some of these packages implement specialized statistical methods. Some (the recommended packages) are distributed with every binary distribution of R. Most packages are available for download from CRAN and other repositories such as Bioconductor, a large repository of tools for the analysis and comprehension of high-throughput genomic data. Once installed, a package has to be loaded into the session to be used. 3.15.1 Install packages from CRAN Using an R package or library for the first time requires two steps: installing the library and loading the library with the following functions: install.packages(): Install the package library(): load the package Example: How to install and load the library “survival”? install.packages(&quot;survival&quot;) # you only need to do this once library(survival) # load library 3.15.2 Install packages from GitHub To install packages grom GitHub make sure you have the newest version of the devtools package. To do so run: install.packages(&quot;devtools&quot;) Then you have two options: Use the install_github() function. install_github(&quot;Momocs&quot;,username=&quot;jfpalomeque&quot;) Another way is trying to download the zip file and install it with the normal install.packages() function in R with: install.packages(file_name_and_path, repos = NULL, type=&quot;source&quot;) 3.16 Help and documentation help( ) or ? : provides information about a function or an object Example: help(mean) ?mean help.search( ): provides information about a topic Example: help.search(&quot;logistic regression&quot;) 3.17 Interesting references: R Tutorial. An R Introduction to Statistics QUICK-R Cookbook for R Gaston Sanchez blog An Introduction to R from R Development Core Team Programming in R by T.Girke R &amp; Bioconductor by T.Girke 3.18 Exercises 3.18.1 Part I Create a new script called “intro_R_xxx.R” (replace xxx by your surname) that contains the code of the following exercises. Code to execute a script called “myscript.R” Code to assign the value A to a variable x Code to generate a sequence from 7 to 30 with increment 3 Code to obtain information about function glm Code to list all the objects in the current environment Code to remove all objects Code to specify the following path to the working directory: C: Create a vector x containing the numbers 1, 2, 1, 1, 1, 2 Create a vector y containing the words yes, no, no, yes, no Compute the number of elements in vector y Code to obtain the sequende of integer numbers from 10 to 25 Use the function rep() to generate the sequence 1, 2, 1, 2, 1, 2 Code to generate the sequence 1, 1, 1, 2, 2, 2 Code to generate a sequence containing 7 yes and 5 no Code to obtain the sequence 40, 35, 30, 25, 20, 15, 10 3.18.2 Part II This exercise uses data describing 128 microarray samples as a basis for exploring R functions. Covariates such as age, sex, type, stage of the disease, etc., are in a data file pData.txt. Input the text file using read.table, assigning the input to a variable pdata. Find the class of the variables pheno and sex. Convert them into factors using as.factor. Show the 10 first values of the variable “age”. Repeat the previous values, each 3 times. Create a new data.frame “pdata_subset” containing the first 20 rows. Add in the previous dataset a new column of random values “Values”, that goes from 0.05 to 0.95. Create a new matrix “Data_matrix” containing the information of the variables “X1”, “X3” and “X5”, uniquely for the last 10 observations of the original “pdata” dataset. Print a sentence indicating the dimensions (rows and columns) of the matrix. Use the function print, paste, nrow and ncol to do so. The sentence should be “The matrix has XXXX rows and XXX columns”. "],["section-3.-basic-data-management.html", "4 SECTION 3. Basic data management 4.1 Accessing information and creating new variables 4.2 Data types and data conversions 4.3 Subsetting datasets 4.4 Recoding variables 4.5 Merging datasets 4.6 Sorting data 4.7 Regular expressions and pattern matching and replacement 4.8 Exercises Data Management (Optional)", " 4 SECTION 3. Basic data management 4.1 Accessing information and creating new variables In a typical research project, you’ll need to create new variables and transform existing ones. This is accomplished with statements of the form: variable &lt;- expression Example Let’s say that you have a data frame named mydata, with variables x1 and x2, mydata &lt;- data.frame(x1=runif(100), x2=runif(100)) head(mydata) ## x1 x2 ## 1 0.7199817 0.8487551 ## 2 0.2082622 0.5207105 ## 3 0.5175099 0.4629578 ## 4 0.1713058 0.1117404 ## 5 0.8362900 0.6525250 ## 6 0.2970242 0.6116609 and you want to create a new variable sumx that adds these two variables and a new variable called meanx that averages the two variables. If you use the code sumx &lt;- x1 + x2 meanx &lt;- (x1 + x2)/2 you’ll get an error, because R doesn’t know that x1 and x2 are from data frame mydata. If you use this code instead, the statements will succeed but you’ll end up with a data frame (mydata) and two separate vectors (sumx and meanx). sumx &lt;- mydata$x1 + mydata$x2 meanx &lt;- (mydata$x1 + mydata$x2)/2 head(mydata) ## x1 x2 ## 1 0.7199817 0.8487551 ## 2 0.2082622 0.5207105 ## 3 0.5175099 0.4629578 ## 4 0.1713058 0.1117404 ## 5 0.8362900 0.6525250 ## 6 0.2970242 0.6116609 Ultimately, you want to incorporate new variables into the original data frame: mydata &lt;- data.frame(x1 = c(2, 2, 6, 4), x2 = c(3, 4, 2, 8)) head(mydata) ## x1 x2 ## 1 2 3 ## 2 2 4 ## 3 6 2 ## 4 4 8 mydata$sumx &lt;- mydata$x1 + mydata$x2 mydata$meanx &lt;- (mydata$x1 + mydata$x2)/2 head(mydata) ## x1 x2 sumx meanx ## 1 2 3 5 2.5 ## 2 2 4 6 3.0 ## 3 6 2 8 4.0 ## 4 4 8 12 6.0 An alternative is to use the function attach() which specifies the data frame to be used and variables in the data frame can be accessed by simply giving their names. attach(mydata) ## The following objects are masked _by_ .GlobalEnv: ## ## meanx, sumx x1 + x2 ## [1] 5 6 8 12 The function detach() removes the attachment: detach(mydata) Also, we can use with(): mean(mydata$x1) ## [1] 3.5 with(mydata,mean(x1)) ## [1] 3.5 4.2 Data types and data conversions R provides a set of functions to identify an object’s data type and convert it to a different data type. Type conversions in R work in a similar fashion to those in other statistical programming languages. Some functions that you can use are: class() is.numeric() - as.numeric() is.character() - as.character() is.vector() - as.vector() is.matrix() - as.matrix() is.data.frame() - as.data.frame() is.factor() - as.factor() is.logical() - as.logical() Functions of the form is.datatype(), return TRUE or FALSE, whereas as.datatype() converts the argument to that type. Examples Is “a” numeric, integer, vector? a &lt;- c(1.3,2.1,3.8) is.numeric(a) ## [1] TRUE is.integer(a) ## [1] FALSE is.vector(a) ## [1] TRUE If we force “a” to be transformed to something else… a &lt;- as.character(a) a ## [1] &quot;1.3&quot; &quot;2.1&quot; &quot;3.8&quot; is.numeric(a) ## [1] FALSE is.vector(a) ## [1] TRUE is.character(a) ## [1] TRUE And again… a &lt;- as.integer(a) a ## [1] 1 2 3 is.numeric(a) ## [1] TRUE is.integer(a) ## [1] TRUE is.vector(a) ## [1] TRUE Notice that: An object can be more than one “type” of data. For instance, vector AND numeric, vector AND character, vector AND numeric AND integer R will always identify characters with the following notation: “something”. It doesn’t matter if inside the quotation marks there are is numbers or letters. In R, factor() is used to convert a categorical variable into a factor in R: a ## [1] 1 2 3 a &lt;- factor(x = a, levels = c(1,2,3),labels = c(&quot;Group1&quot;,&quot;Group2&quot;,&quot;Group3&quot;)) a ## [1] Group1 Group2 Group3 ## Levels: Group1 Group2 Group3 In this example, we start with a numeric vector a, and we use factor() to convert it into a factor. We specify custom levels and labels to map numeric values to meaningful categories. By default the levels of a factor are ordered alphabetically, being the first level the “reference” level. However you may want to use relevel() to change the reference level of a factor variable. It can be useful when you want to set a specific category as the reference for modelling or plotting: b &lt;- as.factor(c(&quot;male&quot;,&quot;male&quot;,&quot;female&quot;,&quot;male&quot;,&quot;female&quot;)) b ## [1] male male female male female ## Levels: female male b2 &lt;- relevel(x=b, ref=&quot;male&quot;) b2 ## [1] male male female male female ## Levels: male female Notice that changing the reference levels does not affect to the original vector. We can also use the function str() to check the different data types contained in a data frame (i.e., structure). First, load ‘rdatos’ data frame. rdatos &lt;- read.table(&quot;RDatosLesson2.txt&quot;,header = T,sep=&quot; &quot;) names(rdatos) ## [1] &quot;ID&quot; &quot;Age&quot; ## [3] &quot;Gender&quot; &quot;Edu&quot; ## [5] &quot;Systolic.Blood.Pressure&quot; &quot;Diastolic.Blood.Pressure&quot; ## [7] &quot;Sleep.Problems&quot; &quot;Caregiver..&quot; ## [9] &quot;Anxiety&quot; &quot;Country&quot; dim(rdatos) ## [1] 1000 10 str(rdatos) ## &#39;data.frame&#39;: 1000 obs. of 10 variables: ## $ ID : int 1 2 3 4 5 6 7 8 9 10 ... ## $ Age : int 53 53 63 52 58 56 57 67 72 55 ... ## $ Gender : int 2 2 2 2 2 1 2 2 2 1 ... ## $ Edu : int 22 11 4 13 14 11 8 12 8 15 ... ## $ Systolic.Blood.Pressure : int NA 100 114 96 117 116 134 137 148 88 ... ## $ Diastolic.Blood.Pressure: int 76 63 72 64 68 64 70 72 75 64 ... ## $ Sleep.Problems : int 2 1 2 1 2 1 2 1 1 1 ... ## $ Caregiver.. : int 2 1 2 1 2 1 1 1 1 1 ... ## $ Anxiety : int 2 2 2 2 2 1 2 2 1 2 ... ## $ Country : chr &quot;Spain&quot; &quot;Spain&quot; &quot;Spain&quot; &quot;Spain&quot; ... Remember that a very convenient function for having a general idea of our data is: summary(rdatos) ## ID Age Gender Edu ## Min. : 1.0 Min. :40.0 Min. :1.000 Min. : 1.00 ## 1st Qu.: 250.8 1st Qu.:54.0 1st Qu.:1.000 1st Qu.: 8.00 ## Median : 500.5 Median :58.0 Median :2.000 Median :10.00 ## Mean : 500.5 Mean :57.9 Mean :1.596 Mean :10.01 ## 3rd Qu.: 750.2 3rd Qu.:61.0 3rd Qu.:2.000 3rd Qu.:12.00 ## Max. :1000.0 Max. :74.0 Max. :2.000 Max. :22.00 ## NA&#39;s :28 NA&#39;s :22 NA&#39;s :24 ## Systolic.Blood.Pressure Diastolic.Blood.Pressure Sleep.Problems ## Min. : 54.0 Min. :55.00 Min. :1.000 ## 1st Qu.:106.0 1st Qu.:66.00 1st Qu.:1.000 ## Median :119.0 Median :70.00 Median :1.000 ## Mean :119.6 Mean :69.82 Mean :1.307 ## 3rd Qu.:132.0 3rd Qu.:73.00 3rd Qu.:2.000 ## Max. :186.0 Max. :85.00 Max. :2.000 ## NA&#39;s :22 NA&#39;s :24 NA&#39;s :20 ## Caregiver.. Anxiety Country ## Min. :1.000 Min. :1.000 Length:1000 ## 1st Qu.:1.000 1st Qu.:1.000 Class :character ## Median :1.000 Median :2.000 Mode :character ## Mean :1.399 Mean :1.637 ## 3rd Qu.:2.000 3rd Qu.:2.000 ## Max. :2.000 Max. :2.000 ## NA&#39;s :30 NA&#39;s :23 As you can observe, the columns ‘ID,’ ‘Gender,’ ‘Sleep Problems,’ ‘Caregiver,’ and ‘Anxiety’ are currently represented as numeric vectors in our dataset. However, it’s important to note that these columns are essentially dummy variables (with the exception of the ‘ID’ column). Dummy variables typically encode categorical information using numeric values, where each unique category corresponds to a specific number. As part of this lesson, we will explore the process of recoding dummy variables to enhance the informativeness of our dataset. 4.3 Subsetting datasets R has powerful indexing features for accessing the elements of an object. These features can be used to select and exclude variables, observations, or both. 4.3.1 Selecting (keeping) variables It’s a common practice to create a new dataset from a limited number of variables chosen from a larger dataset. The elements of a data frame are accessed using the notation data frame[row indices, column indices]. You can use this to select variables. The statement: newdata &lt;- rdatos[, c(1,3)] selects the two columns from the ‘rdatos’ data frame and saves them to ‘newdata’ data frame. Leaving the row indices blank [,] (before the comma) selects all the rows by default. The statement myvars &lt;- c(&quot;ID&quot;, &quot;Gender&quot;) newdata &lt;-rdatos[myvars] accomplish the same variable selection. Here, variable names (in quotes) have been entered as column indices, thereby selecting the same columns. 4.3.2 Excluding (dropping) variables There are many reasons to exclude variables. For example, if a variable has several missing values, you may want to drop it prior to further analyses. You could exclude variable Gender with the statement: myvars &lt;- names(rdatos) %in% c(&quot;Gender&quot;,&quot;Age&quot;) newdata &lt;- rdatos[!myvars] Remember that we use %in% to create a logical vector of the columns names that match Gender. Then, the exclamation mark (!) is used to negate or reverse the logical values in a logical vector. In other words, it flips TRUE values to FALSE and FALSE values to TRUE: myvars ## [1] FALSE TRUE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE !myvars ## [1] TRUE FALSE FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE Knowing that Gender is the 3rd variable, you could exclude it by using its index: newdata &lt;- rdatos[,-3] 4.3.3 Selecting or excluding observations Selecting or excluding observations (rows) is typically a key aspect of successful data preparation and analysis. Examples Ask for rows 1 to 3 (first three observations). Notice that after subsetting, the ‘newdata’ data frame has only 3 rows and 10 columns, since we haven’t specify anything after the comma in [,]. newdata &lt;- rdatos[1:3,] 4.3.4 Conditional selection of data In data analysis, it’s often crucial to select specific rows from our dataset based on certain conditions. This allows us to focus on the data that is relevant to our analysis. In R, we use logical operators to create these conditions. Here are some common logical operators: &lt;: Less than &lt;=: Less than or equal to &gt;: Greater than &gt;=: Greater than or equal to ==: Equal to !=: Not equal to !x: Not x x &amp; y: x AND y x | y: x OR y For example, if we want to select individuals who are older than 55 years old: selected_data &lt;- rdatos[which(rdatos$Age &gt; 55),] In this example, the logical condition rdatos$Age &gt; 55 produces a logical vector of TRUE and FALSE values for each row. We then use the which() function to identify the row indices where the condition is met (i.e., where it’s TRUE), and we store the selected data in a new variable. You can also use logical operators to select data based on multiple conditions. For example, to select individuals who are both older than 55 and have a ‘Gender’ value of 1: newdata &lt;- rdatos[which(rdatos$Age &gt; 55 &amp; rdatos$Gender == 1),] By combining logical conditions with &amp; (AND) or | (OR), you can create more complex conditions to filter and select the data that meets your analysis requirements. 4.3.4.1 The subset() function in R In R, the subset() function is a versatile tool for selecting specific variables (columns) and observations (rows) from your data. It offers a simple way to filter and extract the data you need. The general format of the subset() function is as follows: subset(object, subset = logical_expression, select = columns) You can use this function to subset data frames, matrices, or vectors. Here’s a breakdown of its components: object: The data object you want to subset. subset: The logical condition that specifies which rows to keep. select: The columns you want to select from the data. Let’s explore some practical examples to understand how the subset() function works. Retrieve all rows where the ‘Age’ column contains values less than 70. We will keep only the ‘ID,’ ‘Age,’ and ‘Gender’ variables. newdata1 &lt;- subset(rdatos, Age &lt; 70, select=c(ID, Gender, Age)) 4.3.4.2 Logical OR operator | Retrieve all rows where the ‘Age’ column contains values either lesser than or equal to 55, OR less than 70. newdata2 &lt;- subset(rdatos, Age &lt;= 55 | Age &lt; 70, select=c(ID, Gender, Age)) Notice that we subset exactly the same individuals by using the two expression above: identical(newdata1,newdata2) ## [1] TRUE That’s because we are using the | operator, for which only one of the two logical values needs to be TRUE for the entire OR operation to evaluate to TRUE: TRUE | FALSE ## [1] TRUE FALSE | TRUE ## [1] TRUE TRUE | TRUE ## [1] TRUE FALSE | FALSE ## [1] FALSE This means that we’ll only remove individuals that do not met any of the both conditions: individuals older than 70. 4.3.4.3 Logical AND operator &amp; Now, we’ll retrieve all rows where the ‘Age’ column contains values greater than or equal to 55, AND less than 70. newdata4 &lt;- subset(rdatos, Age &gt;= 55 &amp; Age &lt; 70, select=c(ID, Gender, Age)) With the expression above, we have filtered and selected individuals who satisfy both conditions: those aged 55 or older and those younger than 70. Finally, we’ll retrieve all rows where the ‘Age’ column contains values either lesser than or equal to 55, AND less than 70. newdata5 &lt;- subset(rdatos, Age &lt;= 55 &amp; Age &lt; 70, select=c(ID, Gender, Age)) With the expression above, we’ve selected individuals who satisfy both conditions. This last expression subsets the same data as the following one, as all individuals aged 55 or younger also meet the condition of being younger than 70: newdata6 &lt;- subset(rdatos, Age &lt;= 55, select=c(ID, Gender, Age)) identical(newdata5,newdata6) ## [1] TRUE 4.3.5 Managing missing values Data sets are likely to be incomplete because of missed questions, faulty equipment, or improperly coded data. In R, missing values are represented by the symbol NA (not available). Impossible values (for example, dividing by 0) are represented by the symbol NaN (not a number). R provides a number of functions for identifying observations that contain missing values. The function is.na() allows you to test for the presence of missing values. Example Assume that you have a vector: y &lt;- c(1, 2, 3, NA) is.na(y) ## [1] FALSE FALSE FALSE TRUE then the function is.na(y) returns c(FALSE, FALSE, FALSE, TRUE). Now, we can easily count how many ‘NA’ there are in our data frame with this expression: colSums(is.na(rdatos)) ## ID Age Gender ## 0 28 22 ## Edu Systolic.Blood.Pressure Diastolic.Blood.Pressure ## 24 22 24 ## Sleep.Problems Caregiver.. Anxiety ## 20 30 23 ## Country ## 0 Once you’ve identified the missing values, you need to eliminate them in some way before analysing your data further. The reason is that arithmetic expressions and functions that contain missing values yield missing values. For example, consider the following code: x &lt;- c(1, 2, NA, 3) y &lt;- x[1] + x[2] + x[3] + x[4] y ## [1] NA z &lt;- sum(x) z ## [1] NA Both y and z will be NA (missing) because the third element of x is missing. Luckily, most numeric functions have a na.rm=TRUE option that removes missing values prior to calculations and applies the function to the remaining values: x &lt;- c(1, 2, NA, 3) y &lt;- sum(x, na.rm=TRUE) y ## [1] 6 You may also want to maintain only complete cases for further analyses… rdatos_noNA &lt;- na.omit(rdatos) rdatos_cc &lt;- rdatos[complete.cases(rdatos),] or only remove rows that contain NA in specific columns: rdatos_noNA_Age &lt;- rdatos[complete.cases(rdatos[,&quot;Age&quot;]),] colSums(is.na(rdatos)) ## ID Age Gender ## 0 28 22 ## Edu Systolic.Blood.Pressure Diastolic.Blood.Pressure ## 24 22 24 ## Sleep.Problems Caregiver.. Anxiety ## 20 30 23 ## Country ## 0 colSums(is.na(rdatos_noNA_Age)) ## ID Age Gender ## 0 0 22 ## Edu Systolic.Blood.Pressure Diastolic.Blood.Pressure ## 24 22 24 ## Sleep.Problems Caregiver.. Anxiety ## 20 30 23 ## Country ## 0 4.4 Recoding variables Recoding variables involves transforming existing values of a variable based on specific conditions. This process allows us to create new categories or values, replace incorrect entries, or reformat data to better suit our analysis needs. Here are some common scenarios where recoding is useful: Converting a continuous variable into categories for easier interpretation. Creating binary variables like “pass/fail” based on predefined cut-off scores. *Correcting or replacing misclassified or miscoded values. We can recode variables in R using various methods. Let’s explore a few examples: 4.4.1 Subsetting and assigning One way to recode variables is by subsetting rows based on specific conditions and assigning new values. For instance, let’s create a new categorical column ‘Agecat’ based on the ‘Age’ column: rdatos$Agecat[rdatos$Age &gt; 70] &lt;- &quot;Elder&quot; rdatos$Agecat[rdatos$Age &gt;= 50 &amp; rdatos$Age &lt;= 70] &lt;- &quot;Middle Aged&quot; rdatos$Agecat[rdatos$Age &lt; 50] &lt;- &quot;Young&quot; table(rdatos$Agecat) ## ## Elder Middle Aged Young ## 10 912 50 4.4.2 Using the within() function The within() function allows you to make multiple changes within a data frame. Here, we create ‘Agecat’ and ‘GenderRN’ columns based on conditions: rdatos &lt;- within(rdatos,{ ## note: curly brackets indicate several changes will be made Agecat &lt;- NA Agecat[Age &gt; 70] &lt;- &quot;Elder&quot; Agecat[Age &gt;= 50 &amp; Age &lt;= 70] &lt;- &quot;Middle Aged&quot; Agecat[Age &lt; 50] &lt;- &quot;Young&quot; }) table(rdatos$Agecat) ## ## Elder Middle Aged Young ## 10 912 50 rdatos &lt;- within(rdatos,{ GenderRN &lt;- NA GenderRN[Gender==2] &lt;- &quot;Female&quot; GenderRN[Gender==1] &lt;- &quot;Male&quot;}) head(rdatos[,c(&quot;ID&quot;,&quot;Age&quot;,&quot;Agecat&quot;,&quot;Gender&quot;,&quot;GenderRN&quot;)]) ## ID Age Agecat Gender GenderRN ## 1 1 53 Middle Aged 2 Female ## 2 2 53 Middle Aged 2 Female ## 3 3 63 Middle Aged 2 Female ## 4 4 52 Middle Aged 2 Female ## 5 5 58 Middle Aged 2 Female ## 6 6 56 Middle Aged 1 Male 4.4.3 Using the ifelse() function. The ifelse() function is handy for recoding based on conditions.It allows you to create new values for a variable depending on whether a specified condition is true or false. rdatos &lt;- within(rdatos,{ GenderRN &lt;- NA GenderRN &lt;- ifelse(Gender == 2, &quot;Female&quot;, &quot;Male&quot;) }) If the condition Gender == 2 is met, it assigns “Female” to ‘GenderRN’ for that observation. If the condition is not met, it assigns “Male”. This method is particularly useful when you want to apply different transformations to your data based on various conditions: rdatos &lt;- within(rdatos,{ Agecat &lt;- NA Agecat &lt;- ifelse(Age &gt; 70, &quot;Elder&quot;, ifelse(Age &gt;= 50 &amp; Age &lt;= 70, &quot;Middle Aged&quot;, &quot;Young&quot;)) }) The ifelse() function evaluates each condition sequentially. If the first condition is met (Age &gt; 70), it assigns “Elder” to ‘Agecat’ for that observation. If the first condition is not met, it moves to the second condition (Age &gt;= 50 &amp; Age &lt;= 70) and assigns “Middle Aged” if it’s true. If neither of the first two conditions is met, it defaults to “Young.” 4.5 Merging datasets When your data is scattered across multiple locations or sources, it’s essential to combine them into a single dataset for comprehensive analysis. In R, you can achieve this through the process of merging datasets. Merging involves both adding columns horizontally and adding rows vertically, depending on your data integration needs. 4.5.1 Adding columns (Horizontal merge) To merge two datasets horizontally, you can use the merge() function. Typically, datasets are joined using one or more common key variables that exist in both datasets. Here’s an example of how to do this: Example: Suppose we have two data frames, dataframeA and dataframeB, each containing information about individuals, including an ‘ID’ variable: ## Create dataframeA dataframeA &lt;- data.frame(ID= seq(1,100,1), ID2= seq(1,100,1), X1=runif(100), X2=rnorm(100), Country=rep(c(&quot;Spain&quot;, &quot;EEUU&quot;, &quot;Iceland&quot;), times=c(50,25,25))) ## Create dataframeB dataframeB &lt;- data.frame(ID= seq(1,100,1), Y1=rnorm(100), Y2=rnorm(100), Country=rep(c(&quot;Spain&quot;, &quot;EEUU&quot;, &quot;Iceland&quot;), times=c(30,45,25))) To merge dataframeA and dataframeB based on the ‘ID’ variable: total &lt;- merge(dataframeA, dataframeB, by=&quot;ID&quot;) This merges the two data frames using ‘ID’ as the common key, combining their columns horizontally. The result is stored in the total data frame. You can also merge data frames using different key variables, as shown below: total &lt;- merge(dataframeA, dataframeB, by.x=&quot;ID2&quot;, by.y=&quot;ID&quot;) Additionally, you can merge data frames using multiple key variables by specifying a vector: total &lt;- merge(dataframeA, dataframeB, by=c(&quot;ID&quot;,&quot;Country&quot;),all=T) Another method to merge datasets horizontally, particularly when you don’t need to specify a common key, is to use the cbind() function. This function concatenates columns from multiple data frames, combining them side by side. It’s especially useful when you want to add new variables to an existing data frame or combine data frames with different observations but matching rows. total &lt;- cbind(dataframeA, dataframeB) The cbind() function simply combines the columns of dataframeB next to the columns of dataframeA to create the total data frame. It’s important to note that the order of columns in the resulting data frame will follow the order in which you pass the data frames to cbind(). This method is convenient when you have datasets with different variables but want to append them horizontally, such as adding new variables to an existing dataset. However, if you have a common key to join datasets based on matching rows, the merge() function, as explained earlier, is more appropriate. 4.5.2 Adding rows (Vertical merge) Vertical concatenation is typically used to add observations to a data frame. To join two data frames (datasets) vertically, use the rbind() function. total &lt;- rbind(dataframeA, dataframeB) when using rbind() to merge data frames vertically, the columns in both data frames must have the same names to work correctly. If one data frame has columns that are missing in the other data frame, rbind() may produce incomplete results. For example: # Create dataframeA dataframeA &lt;- data.frame(ID = 1:3, Name = c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;)) # Create dataframeB with an additional column dataframeB &lt;- data.frame(ID = 4:6, Age = c(25, 30, 22)) # Attempt to merge using rbind() total &lt;- rbind(dataframeA, dataframeB) If the data types of columns with the same name differ between the data frames, rbind() may coerce them into a common data type. This can lead to data loss or unexpected behaviour. For example: # Create dataframeA with character ID dataframeA &lt;- data.frame(ID = c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;), Name = c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;)) # Create dataframeB with numeric ID dataframeB &lt;- data.frame(ID = c(4, 5, 6), Name = c(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;)) # Attempt to merge using rbind() total &lt;- rbind(dataframeA, dataframeB) 4.6 Sorting data Sometimes, arranging your dataset in a specific order can reveal valuable insights. In R, you can easily sort a data frame using the order() function. Sorting allows you to explore your data in an organized and informative manner. 4.6.1 Sorting by a single variable You can start by sorting your data frame based on one variable. Here’s an example: newdata &lt;- rdatos[order(rdatos$Age),] creates a new dataset containing rows sorted from youngest to oldest. 4.6.2 Sorting alphabetically You can also arrange your data alphabetically based on a categorical variable like ‘Country’: table(rdatos$Country) ## ## France Italy Spain ## 250 250 500 newdata &lt;- rdatos[order(rdatos$Country),] 4.6.3 Sorting by multiple variables This code sorts the rows first alphabetically by ‘Country’ and then within each country by ‘Age,’ providing a comprehensive view of your dataset. newdata &lt;- rdatos[order(rdatos$Country, rdatos$Age),] head(newdata[, c(1, 2, 10)], 10) ## ID Age Country ## 725 725 43 France ## 559 559 47 France ## 583 583 47 France ## 629 629 47 France ## 641 641 49 France ## 675 675 49 France ## 706 706 49 France ## 731 731 49 France ## 630 630 50 France ## 698 698 50 France This code sorts the data by ‘Age’ in ascending order and then, within each age group, by ‘Gender.’ newdata &lt;-rdatos[order(rdatos$Age, rdatos$Gender),] head(newdata[, c(1, 2, 3)], 10) ## ID Age Gender ## 38 38 40 1 ## 725 725 43 1 ## 485 485 44 1 ## 761 761 44 1 ## 324 324 44 2 ## 246 246 45 2 ## 23 23 46 1 ## 895 895 46 1 ## 220 220 46 2 ## 376 376 46 2 4.7 Regular expressions and pattern matching and replacement Regular expressions, often referred to as regex or regexp, are sequence of characters that defines a search pattern and are powerful tools for pattern matching and text manipulation. In R, you can use regular expressions to search, extract, and manipulate text data. Let’s dive into the basics of regular expressions in R. Regular expressions are defined using a combination of characters and special symbols. 4.7.1 Basic functions to detect patterns in R R provides several functions for working with regular expressions, including: grep(pattern, x, value = FALSE, ignore.case = FALSE): Search for a pattern in a character vector or text. It returns a vector of the indeces of the element that yielded a match. To return the value of the element that yielded a match, set value =T. For non-case-sensitive matching set ignore.case = TRUE. grepl(pattern, x): Check if a pattern exists in a character vector or text. It returns a vector of logical values (match or not for each element of the vector). Here are some examples for the use of grep() and grepl(): intro &lt;- c(&quot;2025/26&quot;,&quot;Lesson 2&quot;, &quot;Importance of the use of regular expressions in R&quot;,&quot;4&quot;,&quot;Omics&quot;,&quot;&quot;,&quot;exprress&quot;) Notice grep returns the indices of the elements contained in the vector ‘intro’ that match the pattern. grep(&quot;2&quot;,intro) ## [1] 1 2 grep(&quot;2&quot;,intro, value=T) ## [1] &quot;2025/26&quot; &quot;Lesson 2&quot; grepl(&quot;2&quot;,intro) ## [1] TRUE TRUE FALSE FALSE FALSE FALSE FALSE grep(&quot;4&quot;,intro) ## [1] 4 grep(&quot;4&quot;,intro,value=T) ## [1] &quot;4&quot; grepl(&quot;4&quot;,intro) ## [1] FALSE FALSE FALSE TRUE FALSE FALSE FALSE sub(pattern, replacement, x): Replace the first occurrence of a pattern (inside each one of the elements of the vector) with another string. new &lt;- sub(&quot;2&quot;,&quot;2.&quot;,intro) new ## [1] &quot;2.025/26&quot; ## [2] &quot;Lesson 2.&quot; ## [3] &quot;Importance of the use of regular expressions in R&quot; ## [4] &quot;4&quot; ## [5] &quot;Omics&quot; ## [6] &quot;&quot; ## [7] &quot;exprress&quot; gsub(pattern, replacement, x): Replace all occurrences of a pattern with another string. gsub(&quot;2&quot;,&quot;2.&quot;,intro) ## [1] &quot;2.02.5/2.6&quot; ## [2] &quot;Lesson 2.&quot; ## [3] &quot;Importance of the use of regular expressions in R&quot; ## [4] &quot;4&quot; ## [5] &quot;Omics&quot; ## [6] &quot;&quot; ## [7] &quot;exprress&quot; 4.7.2 Special symbols Here are some commonly used special symbols and their meanings: .: Matches any single character element. Thus, we have a problem if we want to look for “.” inside my character strings… grep(&quot;.&quot;, new, value =T) ## [1] &quot;2.025/26&quot; ## [2] &quot;Lesson 2.&quot; ## [3] &quot;Importance of the use of regular expressions in R&quot; ## [4] &quot;4&quot; ## [5] &quot;Omics&quot; ## [6] &quot;exprress&quot; grepl(&quot;.&quot;, new) ## [1] TRUE TRUE TRUE TRUE TRUE FALSE TRUE Notice that . does not match the sixth element of the vector. Since . is a special symbol, for searching or replacing “.” within a character string, you should use “\\.”: grep(&quot;\\\\.&quot;,new,value=T) ## [1] &quot;2.025/26&quot; &quot;Lesson 2.&quot; You can keep in blank the replacement argument in order to remove a pattern with gsub(pattern, replacement, x): gsub(pattern = &quot;\\\\.&quot;,replacement = &quot;&quot;,x = new) ## [1] &quot;2025/26&quot; ## [2] &quot;Lesson 2&quot; ## [3] &quot;Importance of the use of regular expressions in R&quot; ## [4] &quot;4&quot; ## [5] &quot;Omics&quot; ## [6] &quot;&quot; ## [7] &quot;exprress&quot; *: Matches zero or more occurrences of the preceding character or pattern. For instance, the regular expression pp* can be divided in two: ‘p’ that will match the character p and p* that will match zero or more occurrences of ‘p’. repe &lt;- c(&quot;apple&quot;, &quot;appl&quot;, &quot;appppl&quot;, &quot;banana&quot;, &quot;bppple&quot;, &quot;aple&quot;) grep(&quot;pp*&quot;,repe, value = TRUE) ## [1] &quot;apple&quot; &quot;appl&quot; &quot;appppl&quot; &quot;bppple&quot; &quot;aple&quot; In contrast, the regular expression p* will match zero or more occurrences of ‘p’. That is, everything. grep(&quot;p*&quot;, repe, value = TRUE) ## [1] &quot;apple&quot; &quot;appl&quot; &quot;appppl&quot; &quot;banana&quot; &quot;bppple&quot; &quot;aple&quot; In other words: p*: means zero or more p in a row. pp*: means one p followed by zero or more p. +: Matches one or more occurrences of the preceding character or pattern. grep(&quot;pp+&quot;,repe, value = TRUE) ## [1] &quot;apple&quot; &quot;appl&quot; &quot;appppl&quot; &quot;bppple&quot; That is, pp+ matches any substring with at least two consecutive p. ?: Matches zero or one occurrence of the preceding character or pattern. grep(&quot;r?ess&quot;,new, value = TRUE) ## [1] &quot;Lesson 2.&quot; ## [2] &quot;Importance of the use of regular expressions in R&quot; ## [3] &quot;exprress&quot; grep(&quot;r+ess&quot;,new, value = TRUE) ## [1] &quot;Importance of the use of regular expressions in R&quot; ## [2] &quot;exprress&quot; ^matches the start of a line and $ matches the end of a line. grep(&quot;i&quot;,intro,value = T,ignore.case = T) ## [1] &quot;Importance of the use of regular expressions in R&quot; ## [2] &quot;Omics&quot; grep(&quot;^i&quot;,intro,value = T,ignore.case = T) ## [1] &quot;Importance of the use of regular expressions in R&quot; grep(&quot;\\\\.&quot;,new,value=T) ## [1] &quot;2.025/26&quot; &quot;Lesson 2.&quot; grep(&quot;\\\\.$&quot;,new,value= T) ## [1] &quot;Lesson 2.&quot; []: Matches any one character within the brackets. grep(&quot;[0-9]&quot;,new,value =T) ## [1] &quot;2.025/26&quot; &quot;Lesson 2.&quot; &quot;4&quot; grep(&quot;[a-c]&quot;,new,value =T) ## [1] &quot;Importance of the use of regular expressions in R&quot; ## [2] &quot;Omics&quot; Example: searching full stops that are preceded by digits or slash preceded by digits. grep(&quot;[0-9]\\\\.&quot;,new,value=T) ## [1] &quot;2.025/26&quot; &quot;Lesson 2.&quot; grep(&quot;([0-9]*/)&quot;,new,value =T) ## [1] &quot;2.025/26&quot; [^]: Matches any one character NOT within the brackets. grep(&quot;[^0-9]&quot;,new,value =T) ## [1] &quot;2.025/26&quot; ## [2] &quot;Lesson 2.&quot; ## [3] &quot;Importance of the use of regular expressions in R&quot; ## [4] &quot;Omics&quot; ## [5] &quot;exprress&quot; Special symbols can be combined to create a regular patterns for efficient pattern matching in R. examples &lt;- c(&quot;apple&quot;, &quot;appl&quot;, &quot;appppl&quot;, &quot;banana&quot;, &quot;bppple&quot;, &quot;ress&quot;, &quot;rress&quot;, &quot;rrress&quot;, &quot;ess&quot;, &quot;data.csv&quot;, &quot;report.doc&quot;, &quot;my.file.txt&quot;) grep(&quot;^r+e.s+p*&quot;, examples, value = TRUE) ## [1] &quot;ress&quot; &quot;rress&quot; &quot;rrress&quot; Let’s understand each element of the pattern: - ^: the word should start with the following pattern - r+: one or more r - e: letter e - .: any character - s+: one or more s - p*: zero or more p 4.7.3 Basic functions to locate patterns in R There are other functions that help us to locate a specific pattern inside a character string by specifying the start and end positions of your pattern in a given string. text &lt;- &quot;Alejandra, Berta, Alex, Carles, Joan, Alexander&quot; regexpr(pattern = &quot;Ale&quot;, text = text) ## first occurrence of the pattern ## [1] 1 ## attr(,&quot;match.length&quot;) ## [1] 3 ## attr(,&quot;index.type&quot;) ## [1] &quot;chars&quot; ## attr(,&quot;useBytes&quot;) ## [1] TRUE gregexpr(pattern = &quot;Ale&quot;, text = text) ## detect several occurrences ## [[1]] ## [1] 1 19 39 ## attr(,&quot;match.length&quot;) ## [1] 3 3 3 ## attr(,&quot;index.type&quot;) ## [1] &quot;chars&quot; ## attr(,&quot;useBytes&quot;) ## [1] TRUE The package ‘stringr’ provide efficient functions for the more common string manipulations in R. library(stringr) str_locate(string = text, pattern = &quot;Ale&quot;) ## start end ## [1,] 1 3 str_locate_all(string = text, pattern = &quot;Ale&quot;) ## [[1]] ## start end ## [1,] 1 3 ## [2,] 19 21 ## [3,] 39 41 4.7.4 Split a string using a pattern The str_split function from the ‘stringr’ package is very convenient for renaming and recoding variables. It returns a list of the split strings. If you want to access to each piece of string use the unlist() to create a character vector. text ## [1] &quot;Alejandra, Berta, Alex, Carles, Joan, Alexander&quot; split_list &lt;- str_split(string = text , pattern = &quot;, &quot;) split_list[[1]] ## [1] &quot;Alejandra&quot; &quot;Berta&quot; &quot;Alex&quot; &quot;Carles&quot; &quot;Joan&quot; &quot;Alexander&quot; unlist(split_list)[[2]] ## [1] &quot;Berta&quot; 4.8 Exercises Data Management (Optional) Read file example.txt and store it in a data frame called “example” Show rows 5,11,18 and 20 in data “example” Show variable “sex” for rows from 15 to 50 in data “example” Change the name of the “cc” column to “Case/Control” in data “example” Export “example” to a “csv” semicolon delimited file without the names of the rows and without quotations Retrieve the forth element in vector x=(3, -1, 0, 2, -5, 7, 1) Retrieve the first, second and fifth elements in vector x=(3, -1, 0, 2, -5, 7, 1) Retrieve all the elements in vector x=(3, -1, 0, 2, -5, 7, 1) except the second one Change the value of the first and second elements in x=(3, -1, 0, 2, -5, 7, 1) by 0 Assign the value 0 to the elements in x=(3, -1, 0, 2, -5, 7, 1) that are larger than 2 Create a matrix M with 4 rows and 3 columns and fill it by rows with even numbers from 2 to 24 Obtain the number of rows and columns of matrix M Retrieve the element in the first row and third column of matrix M Retrieve all the elements in the third column of matrix M Retrieve the third and forth elements in the second column of matrix M Retrieve a matrix containing all files in M except the first one Add a new column at the beginning of matrix M with the integers from 1 to 4 Add a row at the end of matrix M with values 2, 4, 8 Generate a data frame called chol (for cholesterol) containing the following variables (columns): id=(1, 2, 3, 4, 5), gender=(1, 1, 2, 1, 2), LDL=(237, 256, 198, 287, 212) In the previous data frame chol use the function rownames() to assign to each row the name of the patient: John, Peter, Hellen, Mat and Mary Show the first 3 rows in data frame chol Retrieve the LDL cholesterol levels of Peter using his position in the data frame Retrieve the LDL cholesterol levels of Peter using his name in the code Save the LDL cholesterol levels of the 5 individuals in a new vector called ldl_chol Create a new data frame named chol_high including only those individuals with LDL levels above 240 Let’s consider the vector x=(0.6, -1.3, 0.98, -0.4, 0.16) and perform a t.test on x for the null hypothesis that the mean is equal to 0 and save the output in an object called ttestx Show the attributes of object ttestx From the output of ttestx retrieve the confidence interval of the mean Check the data type of gender in data frame chol Transform variable gender from data frame chol into a factor variable called gender1 with 1=male and 2=female and with males as the reference group: Transform variable gender from data frame chol into a factor variable called gender2 with 1=male and 2=female and with females as the reference group: Write the data frame chol into a text file called cholesterol.txt Write the data frame chol into a csv file called cholesterol.csv Write the code to install and load the R package `readxl`` from CRAN Get a numerical summary of x=(1.5, 2.3, 4, 5.6, 2.1) Obtain the 40% percentile of x=(1.5, 2.3, 4, 5.6, 2.1) Obtain the percentages of males and females in gender=(1, 1, 2, 1, 2) Obtain the Pearson and Spearman correlation coefficient between x=1:10 and y=x^2 Test for the equality of variances in LDL cholesterol levels between males and females, assuming that LDL levels are normally distributed Test for differences in LDL cholesterol mean levels between males and females, assuming that LDL levels are normally distributed Test for differences in LDL cholesterol mean levels between males and females, without the assumption of normallity "],["section-4.-basic-plots.html", "5 SECTION 4. Basic Plots 5.1 Line charts 5.2 Dot plot 5.3 Bar charts 5.4 Histograms 5.5 Boxplot 5.6 Commbining different plots 5.7 Scatter Plots 5.8 Important graphical functions and parameters 5.9 Saving Graphics to Files", " 5 SECTION 4. Basic Plots Generation of random data for the examples We generate a vector x of 15 values from a normal random distribution with mean=0 and standard deviation=1 and a vector y of 15 values from a normal random distribution with mean=0.2 and standard deviation=1: set.seed(123) x&lt;-rnorm(15,0,1) i&lt;-c(1:15) set.seed(4) y&lt;-rnorm(15,0.2,1) 5.1 Line charts They are particularly valuable for depicting trends over time or sequences of data points. In this example, we are plotting a single numerical vector, “x” which contains 15 data points. The x-axis of the line chart displays an index for each of these 15 data points in the “x” vector. length(x) ## [1] 15 plot(x) #plots the values of x (vertical axis) as a function of the index of each value (horizontal axis) 5.1.1 Key Characteristics: Data type: Line charts are suitable for visualizing one-dimensional numerical data. x-Axis: In a line chart, the x-axis typically represents the index or sequence of data points, especially when plotting a single vector. Y-Axis: The y-axis represents the values of the numerical variable being plotted. 5.1.2 Use Cases: Sequential Data: They are well-suited for visualizing sequences of data points or events. Trend Analysis: Line charts are excellent for identifying trends or patterns in data, such as changes over time (e.g., observe the trend of monthly blood pressure measurements for 1 year) 5.1.3 Customization Options: col (color): You can specify the colour of the points or lines in the chart. pch (point character): This option lets you choose the symbol or marker for data points. main (main title): You can add a title to the plot using the main parameter within the plot() function. type (line type): You can control whether lines are drawn between points, or if only points are plotted. xlab (x-axis label): Customize the label for the x-axis. ylab (y-axis label): Customize the label for the y-axis. xlim and ylim (axis limits): Define the range of values displayed on the x and y axes, respectively. plot(x, col = 3, type=&quot;o&quot;, pch= 3,xlab=&quot;This is the x label&quot;,ylab=&quot;This is the y label&quot;, main = &quot;Title of the plot&quot;) The points() function allows to introduce supplementary data points to an existent plot. This functionality is especially handy when you wish to expand upon an already-created graph, incorporating additional information without recreating the entire plot. plot(x, type=&quot;o&quot;, xlab=&quot;&quot;,ylim=c(-1.5,2.5)) points(y, col=2) The lines() function allows you to incorporate additional data points and connecting them with lines. This function is particularly useful when you have multiple datasets or want to illustrate the relationship between different several one-dimensional numerical variables within the same plot. plot(x, type=&quot;o&quot;, xlab=&quot;&quot;,ylim=c(-1.5,2.5)) lines(y, type=&quot;o&quot;, col=2) The range function in the context of plotting is a convenient tool for automatically determining the minimum and maximum values among two datasets, denoted as ‘x’ and ‘y’. This function eliminates the need for manual inspection to identify the extreme values on both the x and y-axes, ensuring that your plot is appropriately scaled for optimal visualization. range(x,y) ## [1] -1.265061 2.096540 plot(x, type=&quot;o&quot;, xlab=&quot;&quot;, ylim=range(x,y)) lines(y, type=&quot;o&quot;, col=2) 5.2 Dot plot Dot plots, generated using the dotchart() function, are a valuable tool for visualizing the distribution and ranking of numerical data. These plots resemble line charts, but with a key distinction: in dot plots, the numerical variable’s values are plotted along the horizontal axis, while the vertical axis is used to represent data points’ indices. dotchart(x, labels=i) 5.2.1 Key characteristics Data type Dot plots are primarily used for visualizing a single numerical variable (commonly referred to as ‘x’). X-Axis: The values of the numerical variable (‘x’) are plotted along the horizontal axis, making it easy to compare the magnitudes of data points. Vertical Axis: The vertical axis represents data point indices or labels, aiding in identifying individual data points. 5.2.2 Use cases They are well-suited for displaying the distribution of data and ranking data points based on their values. dotchart(x[order(x)], labels=order(x)) 5.3 Bar charts Bar charts are used to visualize categorical or discrete data. They are suitable for representing data with distinct categories or groups, such as types of gene expression levels by tissue types (i.e., liver, heart, brain) or protein abundance levels by experimental conditions (i.e., control, treatment A, treatment B). In R, we use the barplot() function to create bar charts: group &lt;- c(&quot;A&quot;,&quot;B&quot;,&quot;C&quot;) count &lt;- c(20, 50, 30) barplot(height = count, names.arg =group,density = c(5,30,70), border = 3) In this example, each group (i.e., A, B, C) is represented by a separate bar, and the height of each bar represents the count associated with that group. Notice that the bars are distinct and separate, with gaps between them. 5.3.1 Key characteristics Bar charts are used to compare values between different categories or groups. They help identify trends, differences, or rankings among categories. In the x-axis, each category or group is represented by a separate bar. Each bar corresponds to a unique category, making it easy to compare values across different categories. The length or height of each bar represent the specific value or count associated to each category. 5.3.2 Customization Customization arguments are similar to those explained in the line chart section. For more information, explore the help page in R. ??graphics::barplot 5.3.3 Multiple bar plots Bar plots are also useful to visualized counts across several groups and sub-groups. Let’s create a dataset containing gene expression data for two genes (Gene A and Gene B) measured in three different experimental conditions (Control, Treatment A, Treatment B). # Create a matrix of expression data genes &lt;- c(&quot;Gene A&quot;, &quot;Gene B&quot;) conditions &lt;- c(&quot;Control&quot;, &quot;Treatment A&quot;, &quot;Treatment B&quot;) expression_matrix &lt;- matrix( c( 25, 30, 22, 15, 18, 28 ), nrow = length(genes), ncol = length(conditions), byrow = TRUE, dimnames = list(genes, conditions) ) # Display the expression matrix expression_matrix ## Control Treatment A Treatment B ## Gene A 25 30 22 ## Gene B 15 18 28 With this data, you can create a bar chart to visualize how the expression levels of these two genes vary across the three different experimental conditions. barplot(expression_matrix, col=c(&quot;slateblue3&quot;,&quot;orchid1&quot;), main = &quot;Gene Expression Levels by Condition&quot;, xlab = &quot;&quot;, ylab = &quot;Expression Level&quot;, legend.text = TRUE, args.legend = list(x = &quot;topright&quot;)) You can use the argument beside = T to have a clearer representation of the expression level for each gene under each specific condition. barplot(expression_matrix, beside = TRUE, col=c(&quot;slateblue3&quot;,&quot;orchid1&quot;), main = &quot;Gene Expression Levels by Condition&quot;, xlab = &quot;&quot;, ylab = &quot;Expression Level&quot;, ylim= c(0,45), legend.text = TRUE, args.legend = list( x= 9,y=43)) 5.4 Histograms Histograms are used in statistics and data analysis to visualize the distribution of continuous or numerical discrete data. They provide a way to understand the underlying patterns and characteristics of a dataset. In R, we use hist() for creating histograms: hist(x, col = 5) This basic function generates a histogram for the numeric vector x. By default, it includes a title and x-axis label based on the variable name. We can also represent the distribution of a vector of discrete data “z”. set.seed(321) z &lt;- rpois(1000,5) table(z) ## z ## 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ## 6 21 84 155 170 157 157 102 70 44 19 8 4 2 1 hist(z, col = &quot;royalblue1&quot;,) 5.4.1 Key characteristics Histograms display the distribution of a continuous or discrete numerical variable. This variable is typically plotted on the horizontal (x) axis. The range of values of the numerical variable is divided into intervals or bins. Each bin represents a specific range of values. For each bin, the height of the bar represents the frequency or count of data points that fall into that bin. In other words, it shows how many data points belong to each interval. For continuous data, bins are usually contiguous intervals along the numerical range (e.g., age intervals such as 0-10, 10-20, etc.). For discrete data, each unique value is treated as a separate bin. 5.4.2 Customization Customization arguments are similar to those explained in the line chart section. For more information, explore the help page in R. ??graphics::hist 5.5 Boxplot Boxplots, also known as box-and-whisker plots, are used to visualize the distribution of data and identify potential outliers. They display the median, quartiles, and possible outliers of a dataset. In R, we use theboxplot() function: boxplot(x) title(&quot;boxplot of x&quot;, ylab=&quot;x&quot;) 5.5.1 Key characteristics Univariate Representation: Box plots are designed to visualize a single numerical variable (‘x’) at a time. Summary Statistics: They provide a summary of the distribution of data, including the median, quartiles, and potential outliers. Visualizing Spread: The box in the plot represents the interquartile range (IQR), while the “whiskers” extend to the data’s range. Outliers are typically marked individually. 5.5.2 Use cases Distribution summary: summarize central tendency, variability, identify outliers Comparing groups: compare the distribution of a numerical variable across different groups. Spotting Skewness: a skewed distribution will have a longer tail on one side. 5.5.3 Customization options horizontal: If TRUE, creates horizontal boxplots. outline: If FALSE, hides outliers. at: Determines the x-coordinates of the boxplots when plotting multiple groups. Example: at = c(1, 2, 3) to specify positions for three boxplots. names: Assigns names to the boxplot groups. Example: names = c(“Group A”, “Group B”, “Group C”) legend: Add a legend for multiple boxplots. # Sample data for multiple boxplots data &lt;- list(group1 = rnorm(50), group2 = rnorm(50), group3 = rnorm(50)) # Customize and create boxplots boxplot(data, col = c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;), main = &quot;Customized Boxplots&quot;, xlab = &quot;Groups&quot;, ylab = &quot;Values&quot;, names = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) 5.6 Commbining different plots This is an example of a plot containing both a histogram and a boxplot: hist(x,main=&#39;histogram and boxplot of x&#39;,xlab=&#39;x&#39;,ylim=c(0,12)) add=T : this allows the addition of the boxplot in the histogram axes=F: we remove the axes of the boxplot hist(x,main=&#39;histogram and boxplot of x&#39;,xlab=&#39;x&#39;,ylim=c(0,12)) boxplot(x,horizontal=TRUE,at=10,add=TRUE,axes=FALSE) boxwex: specifies the width of the box hist(x,main=&#39;histogram and boxplot of x&#39;,xlab=&#39;x&#39;,ylim=c(0,12)) boxplot(x,horizontal=TRUE,at=10,add=TRUE,axes=FALSE, boxwex = 5) 5.7 Scatter Plots A scatter plot is a graphical representation that helps visualize the relationship between two numerical variables. It displays individual data points as dots on a two-dimensional plane, where one variable is plotted on the x-axis, and the other is plotted on the y-axis. Scatter plots are especially useful for identifying patterns, correlations, and outliers in data. 5.7.1 Creating a Simple Scatter Plot To create a basic scatter plot in R, you can use the plot() function, providing two vectors for the x and y axes. Here’s an example using a simple mathematical relationship between x and y: # Generate data x ## [1] -0.56047565 -0.23017749 1.55870831 0.07050839 0.12928774 1.71506499 ## [7] 0.46091621 -1.26506123 -0.68685285 -0.44566197 1.22408180 0.35981383 ## [13] 0.40077145 0.11068272 -0.55584113 y &lt;- x^2 # Define y as the squared values of x plot(x,y, main = &quot;Scatter plot x and y&quot;) In this example, x and y are vectors representing the x and y coordinates of the data points. The plot(x, y) command generates a scatter plot with x values on the x-axis and corresponding y values on the y-axis. 5.7.2 Add new data to an existint plot In data visualization, it’s often necessary to add additional data or customize your scatter plots for clarity and insight. In this section, we’ll explore how to improve existing scatter plots. You can use points() to add additional points to an existing plot plot(x,y) x1 &lt;- c(-1,1) # we add points x=1 and x=-1 y1 &lt;- x1^2 points(x1,y1,col=2, pch=3) In this example, we first create a scatter plot (plot(x, y)) and then add new data points (x1 and y1) to the plot using points(). 5.7.3 Adding labels to data points To add labels to data points, you can use the text() function. Here’s how to do it: plot(x,y) points(x1,y1,col=2, pch=4) text(x1+0.1, y1+0.2, col=2, c(&quot;A&quot;, &quot;B&quot;)) In this example, we added labels “A” and “B” to the new data points at positions (x1 + 0.1, y1 + 0.2). 5.7.4 Using legends Legends are helpful for identifying different data series within a plot. You can use the legend() function to add legends to your scatter plot. Here’s an example: plot(x,y) points(x1,y1,col=2, pch=4) legend(-1,2,c(&quot;Original&quot;,&quot;new&quot;),col=c(1,2),pch=c(1,4)) In this example, we placed the legend at coordinates (-1, 2) and labelled the original data as “Original” and the new data as “New”. 5.7.5 Customizing Scatter plots Scatter plots offer various customization options to improve their appearance and readability. Here are some common customization parameters: col.main: Specifies the colour of the plot’s title. font.main: Defines the font of the plot’s title. cex: Controls the proportion of reduction or amplification of fonts. axes=F: remove axes axis(): define new axes box(): creates a box around the plot ann=F: removes annotation lab: define new lables abline(): abline(a,b) adds line y=a+bx lty: type of line Let’s see an example that incorporates some of these customizations: plot(x,y,axes=FALSE) points(x1,y1,col=2, pch=4) legend(-1,3,c(&quot;Original&quot;,&quot;new&quot;),col=c(1,2),pch=c(1,4), cex=0.7) axis(1,pos=c(-0.5,0),at=seq(-2,2,by=0.4)) axis(2,pos=c(-1.5,-0.5),at=seq(0,3,by=0.5)) title(&quot;scatter plot&quot;, col.main = 3, font.main=3) abline(1, -0.7, lty=3) box() 5.7.6 Multiple scatter plots We can use pairs() to create scatter plots of all pair of variables in a data frame (symmetric matrix of plots). set.seed(123) data&lt;-data.frame(x1=runif(10), x2=runif(10), x3=runif(10), x4=runif(10)) pairs(data) 5.8 Important graphical functions and parameters par(): set graphical parameters mfrow: number of pictures per row and column in a plot mar: specifies the margin sizes around the plotting area in order: c(bottom, left, top, right) dev.off() shuts down the specified device Before you change the graphical parameters it is convenient to store the default values. defaultpar&lt;-par() Explore the par{graphics} R Documentation to check main graphical parameters and easily access to other important functions and arguments. Example: par(mfrow=c(2,3)) # puts 6 pictures in a plot distributed in 2 rows and 3 columns hist(data$x1, main=&quot;Histogram x1&quot;) hist(data$x2, main=&quot;Histogram x2&quot;) hist(data$x3, main=&quot;Histogram x3&quot;) boxplot(data$x1, main=&quot;Boxplot x1&quot;) boxplot(data$x2, main=&quot;Boxplot x2&quot;) boxplot(data$x3, main=&quot;Boxplot x3&quot;) par(defaultpar) # reset the default graphical parameters 5.9 Saving Graphics to Files pdf() redirect the plots to a pdf file. Similarly: jpeg, png, ps, tiff. After saving the image, don’t forget to use dev.off() to close the device and finalize the saving process. Example: pdf(&quot;color_chart.pdf&quot;) # creates a pdf file containing the following plot plot(1, 1, xlim=c(1,5.5), ylim=c(0,7), type=&quot;n&quot;, ann=FALSE) text(x = 1:5, y = rep(6.2,5), labels=c(0:4), cex=1:5, col=1:5) points(x = 1:5, y = rep(5,5), cex=1:5, col=1:5, pch=0:4) text((1:5)+0.4, rep(5,5), cex=0.6, (0:4)) ## labels = 0:4 points(1:5, rep(4,5), cex=2, pch=(5:9)) text((1:5)+0.4, rep(4,5), cex=0.6, (5:9)) points(1:5, rep(3,5), cex=2, pch=(10:14)) text((1:5)+0.4, rep(3,5), cex=0.6, (10:14)) points(1:5, rep(2,5), cex=2, pch=(15:19)) text((1:5)+0.4, rep(2,5), cex=0.6, (15:19)) points((1:6)*0.8+0.2, rep(1,6), cex=2, pch=(20:25)) text((1:6)*0.8+0.5, rep(1,6), cex=0.6, (20:25)) dev.off() "],["section-5.-introduction-to-functions.html", "6 SECTION 5. Introduction to Functions 6.1 What is a function? 6.2 Writing your own functions 6.3 Arguments of a function 6.4 Matching Arguments 6.5 Output of a Function 6.6 Basic R Programming 6.7 References", " 6 SECTION 5. Introduction to Functions 6.1 What is a function? A function is an interface to the code, explicitly specified by a set of parameters, that allows to encapsulate an R code that need to be executed numerous times (i.e., reusable blocks), perhaps under slightly different conditions (thanks to the arguments). In R, we can distinguish between different types of functions: built-in R functions, functions defined in R packages and user-defined functions. 6.1.1 Built-in R functions Built-in R functions are those functions that you can call in R without the need of installing or loading any external package from an on-line repository. All built-in functions are contained in the {base} R package which is automatically loaded when you start an R session. Overall, built-in functions in R are thought to compute basic operations, data manipulation, arithmetic, statistical analysis. You already know some of them: sum() mean() str() head() length() dim() order() boxplot class() Functions are R objects. Then, the class of a function is, of course, a “function”: class(sum) ## [1] &quot;function&quot; 6.1.2 Functions defined in R packages Packages are collections of functions that typically serve specific purposes. For example, {ggplot2} is a package which contains functions for data visualization, and {readxl} facilitates working with Excel files. R packages can be obtained from various online repositories like CRAN, Bioconductor, or GitHub. When you install R packages, they are stored in a designated directory or folder on your computer, known as the “library” or “library path”. By default, R utilizes two libraries: a system library for base packages (located in the R installation folder) and a user library for external repository packages. You can find out where your packages are installed by default by running .libPaths(). To use the functions provided by R packages, you need to load the specific package into your current R session. This can be done using either library(package.name) or require(package.name). 6.1.3 User-defined functions User-defined functions in R are functions that you, as a programmer, create and define to perform specific tasks or operations that are not already covered by built-in functions. These functions are written in R script and allow you to encapsulate a series of operations into a reusable unit. Learning to create user-defined functions in R is a significant milestone on your journey to becoming a programmer, not merely a consumer of the R language. It empowers you to write your own code, tailor R to your specific needs, and solve complex problems with custom solutions. As you become more proficient in creating user-defined functions, you may discover that your functions are not only valuable to you but also to the broader R community. You can package your functions, documentation, and data into your own R packages. 6.2 Writing your own functions You can program your own functions in R by using the language construct function(). You can use this construct to specify the function’s name, the arguments or parameters between brackets and the body of your function between curly brackets. functionName &lt;- function(arguments){ statements } functionName: This is the name you choose for your function. It should be a valid R variable name. arguments: Variables or parameters that you pass to the function when you call it. They allow you to provide input to a function and customize its behaviour. statements: The body of the function which is enclosed within curly brackets {} and contains the code that performs the desired computations. You can execute the function by calling it with the specified arguments: functionName(arguments) Let’s create a function that return the square of a number: square &lt;- function(x) { x*x } Now, square() is stored in your global environment. Once a function is written, it can be used just by invoking the name of the function followed by the values that we pass to the arguments, separated by commas and between parentheses. square(x = 5) ## [1] 25 6.3 Arguments of a function There are different ways to know which are the arguments of a function. We can press the the tab key while writing the arguments or, alternatively, use the directive args(). args(square) ## function (x) ## NULL But, in case that we need to know more things about the arguments of a built-in function from a package, you can use the Help page in R (Function lm from the package stats): args(lm) help(lm) ?lm 6.4 Matching Arguments Calling an R function with arguments can be done in two main different ways. Arguments can be matched either by position, where the first value is assigned to the first argument, the second value to second argument, and so on, or by name, where there is no matter in what order the argument is specified. Notice the difference between passing a numerical vector to the first (and unique) argument of our square() function… square(c(1, 3, 5)) ## [1] 1 9 25 and this: square(1, 3, 5) ## Error in square(1, 3, 5): los argumentos no fueron usados (3, 5) Imagine that we would like to generate 50 numbers at random with a normal distribution such that its mean is 1 and its standard deviation is 20. Then, by applying the function rnorm(), 50 is assigned to the n argument, 1 is assigned to the mean argument, and 20 is assigned to the sd argument, all by positional matching. set.seed(12345) rnorm(50,1,20) ## [1] 12.710576 15.189320 -1.186066 -8.069943 13.117749 -35.359119 ## [7] 13.601971 -4.523682 -4.683195 -17.386440 -1.324956 37.346241 ## [13] 8.412557 11.404329 -14.010640 17.337997 -16.727150 -5.631552 ## [19] 23.414253 6.974474 16.592438 30.115702 -11.886569 -30.062748 ## [25] -30.954190 37.101950 -8.632947 13.407596 13.242470 -2.246220 ## [31] 17.237464 44.936671 41.983807 33.648913 6.085424 10.823766 ## [37] -5.481732 -32.241005 36.354677 1.516021 23.570217 -46.607161 ## [43] -20.205311 19.742811 18.089034 30.214588 -27.261976 12.348065 ## [49] 12.663753 -25.135977 It is also possible to mix both methods. Thus, when an argument is matched by name, it is “taken out” from the argument list, and the remaining unnamed arguments are matched in the order that they are listed in the function definition. set.seed(12345) rnorm(50, mean=1, 20) ## [1] 12.710576 15.189320 -1.186066 -8.069943 13.117749 -35.359119 ## [7] 13.601971 -4.523682 -4.683195 -17.386440 -1.324956 37.346241 ## [13] 8.412557 11.404329 -14.010640 17.337997 -16.727150 -5.631552 ## [19] 23.414253 6.974474 16.592438 30.115702 -11.886569 -30.062748 ## [25] -30.954190 37.101950 -8.632947 13.407596 13.242470 -2.246220 ## [31] 17.237464 44.936671 41.983807 33.648913 6.085424 10.823766 ## [37] -5.481732 -32.241005 36.354677 1.516021 23.570217 -46.607161 ## [43] -20.205311 19.742811 18.089034 30.214588 -27.261976 12.348065 ## [49] 12.663753 -25.135977 Notice that if mean or sd are not specified they assume the default values of 0 and 1. These are default parameters values that you can specify in the arguments list when creating your own user-defined function. set.seed(12345) rnorm(50) ## [1] 0.58552882 0.70946602 -0.10930331 -0.45349717 0.60588746 -1.81795597 ## [7] 0.63009855 -0.27618411 -0.28415974 -0.91932200 -0.11624781 1.81731204 ## [13] 0.37062786 0.52021646 -0.75053199 0.81689984 -0.88635752 -0.33157759 ## [19] 1.12071265 0.29872370 0.77962192 1.45578508 -0.64432843 -1.55313741 ## [25] -1.59770952 1.80509752 -0.48164736 0.62037980 0.61212349 -0.16231098 ## [31] 0.81187318 2.19683355 2.04919034 1.63244564 0.25427119 0.49118828 ## [37] -0.32408658 -1.66205024 1.76773385 0.02580105 1.12851083 -2.38035806 ## [43] -1.06026555 0.93714054 0.85445172 1.46072940 -1.41309878 0.56740325 ## [49] 0.58318765 -1.30679883 It is often useful specifying an argument by its name when a function has many arguments. For example, a function with a large list of arguments is lm(), that allows to fit a linear model to a dataset. Other functions with a huge number of arguments are those functions used for generating plots (e.g. plot, hist, boxplot,…) 6.5 Output of a Function As a result, a function usually should return an object. f1 &lt;- function(x, a = 3, b = 1){ a * x + b } f1(3,5,8) ## [1] 23 Notice that, objects created within a function are in a local environment: f2 &lt;- function(x, a = 3, b = 1){ y &lt;- a * x + b } f2(3) They can be returned from the function to the global environment by keeping it in a variable, and then, print the variable: num &lt;- f2(3) print(num) ## [1] 10 In addition, in the body of function, return() can be used to specify the output of the function. functionName &lt;- function(arguments){ statements return(something) } f3 &lt;- function(x, a = 3, b = 1){ y &lt;- a * x + b return(y) } f3(3) ## [1] 10 6.5.1 Examples of functions The following function computes the perimeter of a circumference. The function’s name is “Perimeter”“, the argument is the radius of the circumference Perimeter &lt;- function(x) { p &lt;- 2 * pi * x return(p) } Perimeter(4) ## [1] 25.13274 You can use the perimeter function to calculate the perimeter of a circumference of any radius x. Perimeter(x = 3) ## [1] 18.84956 Perimeter(x = 5) ## [1] 31.41593 Function to compute the area of a rectangle: Area &lt;- function(x,y) { x*y ## length*width } Area(10,7) ## [1] 70 Try to create this function: Imaging we want to create a function to compute both the perimeter (2*x+2*y) and area of a rectangle. In this case we will need to return two outputs. 6.6 Basic R Programming In this section we’ll learn about control-flow constructs in R. These constructs are used to control the execution and flow of the program based on conditions provided. 6.6.1 Conditionals 6.6.1.1 if() statement: One of the most basic programming concepts involves evaluating conditional statements and then performing some action based on the evaluation. Let’s write a very simple conditional using the if() control-flow construct. The if() construct is simply a control statement that takes a conditional statement (involving logical operators) as its argument and then depending on the evaluation initiates some other function. if(1 + 1 == 2) { ##logical statement! print (&quot;Perfect!&quot;) } ## [1] &quot;Perfect!&quot; You can see that in this case the if() statement evaluated to TRUE and it activated the print() function. If the if() statement were FALSE nothing would happen. if(1 + 1 == 3) { print(&quot;Perfect!&quot;) } 6.6.1.2 else() statement: If we wanted R to also do something if the conditional is FALSE we would have to add the else statement. if(1 + 1 == 3) { print (&quot;Perfect!&quot;) }else{ print(&quot;Wrong&quot;)} ## [1] &quot;Wrong&quot; 6.6.1.3 ifelse() statement Instead of using the if() and else control statements, you can just use the ifelse() function. The function takes the arguments test, yes and no. Z &lt;- 1:10 Z.new &lt;- ifelse(test = Z &gt; 2 &amp; Z &lt; 8 , yes = &quot; Yes &quot; , no = &quot; No&quot;) Z.new ## [1] &quot; No&quot; &quot; No&quot; &quot; Yes &quot; &quot; Yes &quot; &quot; Yes &quot; &quot; Yes &quot; &quot; Yes &quot; &quot; No&quot; &quot; No&quot; ## [10] &quot; No&quot; 6.6.2 Loops 6.6.2.1 for() statement A for loop is a programming construct used when you want to perform a task repeatedly, such as iterating through a sequence, a list, or a range of numbers. It automates repetitive tasks, saving time and effort. The structure of a for loop contains: for (loop_variable in sequence) { # Loop body: Code to be executed in each iteration } loop_variable: this value is used to keep track of the current iteration sequence: defines the range of values that the loop variable will take on each iteration loop body: contains the code to be executed in each iteration The easiest way to understand how to use the for() operator is by example: x &lt;- c(20:30) for(i in x) { print(i) } ## [1] 20 ## [1] 21 ## [1] 22 ## [1] 23 ## [1] 24 ## [1] 25 ## [1] 26 ## [1] 27 ## [1] 28 ## [1] 29 ## [1] 30 As you can see, the for loop start by initializing the loop variable with the first value from the sequence. As output, we don’t obtain the numeric vector ‘x’, but rather we consecutively print each one of its values. x ## [1] 20 21 22 23 24 25 26 27 28 29 30 Try to solve this problem with a for loop: provide the sum of the first 10 digits, that’s, 1 + 2 + 3 + 4 + 6 + 7 + 8 + 9 + 10. Try to solve this problem with a for loop: generate 100 values from a standard normal distribution and sum up those values that are larger than 1.3 For and if loops are useful but are computationally not very efficient. You should always think whether there is an alternative R code that does not require loops. 6.6.2.2 The while() statement The while loop starts by evaluating the condition inside the parentheses. If the condition is TRUE, the code inside the loop is executed. count &lt;- 1 while (count &lt;= 5) { print(count) count &lt;- count + 1 } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 count ## [1] 6 Be cautious about the potential for infinite loops, and include safeguards like a maximum iteration count or an escape condition (use break): count &lt;- 1 while (is.numeric(count)) { print(count) if (count == 10) { break } count &lt;- count + 1 } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 6.6.2.3 Avoid loops whenever possible R is a vector-oriented language, which often allows us to avoid writing explicit loops. Instead of summing two vectors with the following code: for(i in 1:length(a)) { c[i] = a[i] + b[i] } R is designed to do all this in a single vectorized operation: c = a + b Compare the execution time of these two processes: x &lt;- runif(1000000) y &lt;- runif(1000000) system.time(z &lt;- x + y) ## user system elapsed ## 0 0 0 system.time(for (i in 1:length(x)) z[i] &lt;- x[i] + y[i]) ## user system elapsed ## 0.07 0.00 0.06 6.6.3 Useful functions to avoid loops The apply() family of functions in R is a set of powerful tools for applying a function to the rows or columns of matrices, arrays, or data frames and avoid using loops in R whenever possible. 6.6.3.1 Function apply() apply( ) is used when we want to apply the same function to every row or column of a matrix or array. This function has 3 arguments: arg1=name of the matrix, arg2=1 if the function is to be applied to the rows or arg2=2 if the function is to be applied to the columns, arg3=function apply(array, margin, function, ...) Note that an array in R is a very generic data type; it is a general structure of up to eight dimensions. For specific dimensions there are special names for the structures. A zero dimensional array is a scalar or a point; a one dimensional array is a vector; and a two dimensional array is a matrix, etc. Example: Assume that x is a matrix of numbers with 4 rows and 3 columns as defined below mat&lt;-matrix(seq(1:12), nrow=4) mat ## [,1] [,2] [,3] ## [1,] 1 5 9 ## [2,] 2 6 10 ## [3,] 3 7 11 ## [4,] 4 8 12 To compute the mean of the rows apply(mat,1,mean) ## [1] 5 6 7 8 To compute the mean of the columns apply(mat,2,mean) ## [1] 2.5 6.5 10.5 Using a user defined function sum.plus.2 &lt;- function(x){ sum(x) + 2 } apply(mat, 1, sum.plus.2) ##sum by row &amp; +2 ## [1] 17 20 23 26 Also, the function can be defined inside the apply function as an anonymous function. Note the lack of curly brackets: apply(mat, 1, function(x) sum(x) + 2) ## [1] 17 20 23 26 More generalized apply(mat, 1, function(x, y) sum(x) + y, y=3) ## [1] 18 21 24 27 6.6.3.2 Function lapply() lapply() function applies a function to elements in a list or a vector and returns the results in a list. The lapply() function becomes especially useful when dealing with data frames. In R the data frame is considered a special type of list, where each column is considered an element of the list. Notice, how we can access to the elements contained in ‘mat.list’ and ‘mat1.df’ in a similar ways: mat.list &lt;- list( X1 = 1:4, X2=5:8, X3 = 9:12) mat.list ## $X1 ## [1] 1 2 3 4 ## ## $X2 ## [1] 5 6 7 8 ## ## $X3 ## [1] 9 10 11 12 mat.list$X1 ## [1] 1 2 3 4 mat.list[2] ## $X2 ## [1] 5 6 7 8 mat1.df &lt;- data.frame(mat) mat1.df ## X1 X2 X3 ## 1 1 5 9 ## 2 2 6 10 ## 3 3 7 11 ## 4 4 8 12 is.list(mat1.df) ## [1] TRUE mat1.df$X1 ## [1] 1 2 3 4 mat1.df[[2]] ## [1] 5 6 7 8 We can therefore apply a function to all the variables in a data frame by using the lapply function. Note that unlike in the apply function there is no margin argument since we are just applying the function to each component of the list. In the data frame mat1.df the variables mat1.1 - mat1.3 are elements of the list mat1.df. These variables can thus be accessed by lapply for example to obtain the sum of each variable in mat1.df lapply(mat1.df, sum) ## $X1 ## [1] 10 ## ## $X2 ## [1] 26 ## ## $X3 ## [1] 42 class(lapply(mat1.df, sum)) ## returns list ## [1] &quot;list&quot; apply(mat1.df, 2, sum) ## X1 X2 X3 ## 10 26 42 class(apply(mat1.df,2, sum)) ## returns integer vector ## [1] &quot;integer&quot; 6.6.3.3 Function sapply() Applies a function to elements in a list or a vector and returns the results in a vector, matrix or a list. sapply(list, function, ..., simplify) When the argument simplify=F then the sapply function returns the results in a list just like the lapply function. However, when the argument simplify=T, the default, then the sapply function returns the results in a simplified form if at all possible. If the results are all scalars then sapply returns a vector. If the results are all of the same length then sapply will return a matrix with a column for each element in list to which function was applied. lapply(mat.list, function(x, y) sum(x) + y, y = 5) ## $X1 ## [1] 15 ## ## $X2 ## [1] 31 ## ## $X3 ## [1] 47 sapply(mat1.df, function(x, y) sum(x) + y, y = 5) ## X1 X2 X3 ## 15 31 47 6.7 References Explore Datacamp tutorials Control Statements in R Programming "],["section-6.-tips-for-efficient-programming.html", "7 SECTION 6. Tips for efficient programming 7.1 Top tips for efficient programming 7.2 Optimizing functions calls 7.3 Memory allocation 7.4 Embrace R’s vectorized paradigm 7.5 Efficient functions: Do as little as possible 7.6 References", " 7 SECTION 6. Tips for efficient programming A major benefit of using R (as opposed to other programming languages), is that coding time is greatly reduced. However if we are not careful, it’s very easy to write programs that are incredibly slow. While optimization such as going parallel can easily double speed, poor code can easily run 100s of times slower. For this reason a priority of an efficient programmer should be to avoid the following common mistakes. If you spend any time programming in R, this book should be considered essential reading. 7.1 Top tips for efficient programming Let’s explore some fundamental strategies to optimize the efficiency of your R code: 1. Vectorization: Tip: Leverage vectorized operations for faster and more concise code. result_vectorized &lt;- (1:10) + 1 2. Avoid growing vectors: Tip: Preallocate memory for vectors to avoid unnecessary copying and enhance performance. result &lt;- numeric(10) for (i in 1:10) { result[i] &lt;- i + 1 } 3. Use apply functions instead of loops: Tip: Replace explicit loops with apply functions for improved readability and efficiency. 4. Explore other packages (reutilize others work!!): Tip: Investigate specialized packages like data.table, tidyverse, and dplyr for optimized data manipulation. 5. Utilize helpful tools: Tip: Employ tools such as microbenchmark, compiler, and memoise for benchmarking, code compilation, and caching, respectively. Use rm(list=ls()) to empty your working environment, rm(list=setdiff(ls(), \"x\")) to remove everything except “x” and gc() for garbage collection and free up memory. 7.2 Optimizing functions calls Efficient R programming involves tapping into underlying C/Fortran routines swiftly. Every R function call eventually triggers corresponding C/Fortran code. For instance, the base R function runif() is essentially a call to C_runif(). Consider the following illustration using a standard R vector x of length n: x= 1:10 x = x + 1 In this example, a single function call to the + function efficiently handles the vector operation. Conversely, using a loop involves multiple function calls for each element, resulting in slower performance due to the cumulative effect of numerous calls. for(i in 1:n) { x[i] &lt;- x[i] + 1 } While the individual function calls in the loop are quick, the aggregate effect of multiple calls can significantly impact performance. Therefore, minimizing function calls and embracing vectorized operations contribute to a more efficient and faster execution of R code. 7.3 Memory allocation An essential aspect of writing efficient R code is prudent memory allocation. Pre-allocating memory, in particular, stands out as a crucial practice. Let’s delve into three methods of creating a sequence of numbers and compare their performance. Method 1: Dynamic growth method1 &lt;- function(n) { myvec &lt;- NULL for(i in 1:n) { myvec &lt;- c(myvec, i) } return(myvec) } Method 2: Pre-allocation with subscripting method2 &lt;- function(n) { myvec &lt;- numeric(n) for(i in 1:n) { myvec[i] &lt;- i } return(myvec) } Method 3: Direct creation of the final object method3 &lt;- function(n) { myvec &lt;- 1:n return(myvec) } To compare the three methods we use the microbenchmark function from the previous chapter By adopting memory-efficient practices, such as pre-allocating vectors (or direct creation of the final object), you can significantly enhance the performance of your R code, especially when dealing with large datasets or extensive computations. n = 10000 summary(microbenchmark(method1(n), method2(n), method3(n))) ## time in nanoseconds ## expr min lq mean median uq max neval ## 1 method1(n) 178660800 190593850 205741501 200510450 214886200 295400900 100 ## 2 method2(n) 358500 413250 485332 431250 456950 3398300 100 ## 3 method3(n) 400 900 18493 2850 8800 1343700 100 ## cld ## 1 a ## 2 b ## 3 b In the output you can see different columns: expr: names of the expressions being benchmarked min: minimum execution time over times evaluations lq: lower quartile (Q1-25th percentile) of execution time, i.e., 25% of executions took this time or less mean: average time over times evaluations median: median time (50th percentile) of execution time uq: upper quartile (Q3-75th percentile) of execution time, i.e., 75% of executions took this time or less max: maximum execution time over times evaluations neval: number of evaluations cld: compact letter display tells you which methods are statistically significant different based on performance. Methods in group a are significantly slower than methods in group b 7.4 Embrace R’s vectorized paradigm Consider the following examples to illustrate the shift towards a more vectorized approach. For example: x &lt;- runif(1000) + 1 logsum &lt;- 0 for(i in 1:length(x)) { logsum &lt;- logsum + log(x[i]) } is a piece R code that has a strong, unhealthy influence from C. Instead we should write logsum &lt;- sum(log(x)) The vectorized approach is not only more concise but also faster, taking full advantage of R’s strengths. summary(microbenchmark( loop_approach = { logsum &lt;- 0 for(i in 1:length(x)) { logsum &lt;- logsum + log(x[i]) } }, vectorized_approach = { logsum &lt;- sum(log(x)) } )) ## expr min lq mean median uq max neval cld ## 1 loop_approach 2448.1 2589.0 3159.228 2844.45 3405.85 7643.4 100 a ## 2 vectorized_approach 34.1 35.3 39.448 38.55 40.80 86.9 100 b Another common example is sub-setting a vector. ans &lt;- NULL for(i in 1:length(x)) { if(x[i] &lt; 0) { ans &lt;- c(ans, x[i]) } } This can be done simply with: ans &lt;- x[x &lt; 0] 7.5 Efficient functions: Do as little as possible Improving the efficiency of your functions often boils down to making them do less work. Here are some strategies and examples to optimize your functions: 1. Use specific vectorized functions: Functions like rowSums(), colSums(), rowMeans(), and colMeans() outperform equivalent operations using apply() because they are inherently vectorized. Example: matrix_data &lt;- matrix(1:20, nrow = 4, ncol = 5, byrow = TRUE) summary(microbenchmark(rowSums(matrix_data),apply(matrix_data, 1, sum))) ## expr min lq mean median uq max neval cld ## 1 rowSums(matrix_data) 4.2 4.55 6.785 5.4 5.80 83.0 100 a ## 2 apply(matrix_data, 1, sum) 24.6 25.00 29.643 25.4 27.45 124.8 100 b 2. Choose appropriate function for specific tasks: Opt for specialized functions like vapply() over general-purpose ones like sapply(). Example: data &lt;- list(a = c(1, 2, 3), b = c(4, 5, 6), c = c(7, 8, 9)) vapply_result &lt;- vapply(data, function(x) mean(x), FUN.VALUE=numeric(1)) vapply_result ## a b c ## 2 5 8 sapply_result &lt;- sapply(data, function(x) mean(x)) sapply_result ## a b c ## 2 5 8 summary(microbenchmark(vapply(data, function(x) mean(x), numeric(1)),sapply(data, function(x) mean(x)))) ## expr min lq mean median uq ## 1 vapply(data, function(x) mean(x), numeric(1)) 23.4 24.3 27.179 25.0 25.85 ## 2 sapply(data, function(x) mean(x)) 37.4 38.3 42.629 39.1 40.25 ## max neval cld ## 1 93.5 100 a ## 2 188.4 100 b The numeric(1) argument specifies that the output should be of type numeric and length 1. This specification enhances performance and makes it faster. 3. Optimize equality testing: If you want to see if a vector contains a single value, any(x == 10) is much faster than 10 %in% x. This is because testing equality is simpler than testing inclusion in a set. 4. Understand data type coercion: Some functions coerce inputs into specific types. Thus, if your input is not the right type, the function has to do extra work. Choose functions that work with your data as it is or consider adapting your data format.The most common example of this problem is using apply() on a data frame. apply() always turns its input into a matrix. Not only is this error prone (because a data frame is more general than a matrix), it is also slower. 5. Provide additional information: Other functions will do less work if you give them more information about the problem. It’s always worthwhile to carefully read the documentation and experiment with different arguments. Some examples that I’ve discovered in the past include: read.csv(): specify known column types with colClasses can enhance parsing efficiency. factor(): specify known levels with levels ensures that the factor levels are correctly assigned, avoiding potential errors and enhancing the function’s accuracy. When unlisting a nested list, using use.names = FALSE in unlist() can significantly improve performance by avoiding the preservation of the names of the list elements, which slow down the operation. l.ex &lt;- list(a = list(1:5, LETTERS[1:5]), b = &quot;Z&quot;, c = NA) l.ex ## $a ## $a[[1]] ## [1] 1 2 3 4 5 ## ## $a[[2]] ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; ## ## ## $b ## [1] &quot;Z&quot; ## ## $c ## [1] NA unlist(l.ex) ## a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 b c ## &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;Z&quot; NA unlist(l.ex,use.names=F) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; &quot;E&quot; &quot;Z&quot; NA interaction(): if you only need combinations that exist in the data, use drop = TRUE. factor_1 &lt;- factor(c(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;)) factor_2 &lt;- factor(c(&quot;X&quot;, &quot;Y&quot;, &quot;X&quot;)) interaction(factor_1, factor_2) ## [1] A.X B.Y A.X ## Levels: A.X B.X A.Y B.Y interaction(factor_1, factor_2,drop =T) ## [1] A.X B.Y A.X ## Levels: A.X B.Y 7.6 References Quick intro into Parallel Computing in R: https://nceas.github.io/oss-lessons/parallel-computing-in-r/parallel-computing-in-r.html Parallel Programming in R: https://www.geeksforgeeks.org/parallel-programming-in-r/ “Efficient R programming” book by Colin Gillespie and Robin Lovelace: https://csgillespie.github.io/efficientR/index.html “The R Language: An Engine for Bioinformatics and Data Science” by Giorgi et al.: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9148156/ “Advanced R”: https://adv-r.hadley.nz/ Rcpp: Seamless R and C++ Integration: https://www.jstatsoft.org/article/view/v040i08 Benchmarks comparisons: https://github.com/Rdatatable/data.table/wiki/Benchmarks-%3A-Grouping "],["section-7.-introduction-to-object-oriented-programming-oop.html", "8 SECTION 7. Introduction to Object-oriented Programming (OOP) 8.1 Object and Class in R 8.2 S3 Classes 8.3 S4 classes", " 8 SECTION 7. Introduction to Object-oriented Programming (OOP) R has a system for object-oriented programming (OOP), which is based on generic functions. In general, OOP is a programming paradigm that uses “objects” and their interactions to design applications and computer programs. In R, some basic concepts concerning OOP are as follows. A class is a description of a thing (i.e., how objects of a certain type look like). An object is an instance of a class. A generic function is a function that dispatches methods based on the type of object passed to it, such as plot, mean, logLik, residuals, predict, summary, and so on and so forth. A method is the implementation of a generic function for an object of a particular class. For example: methods(plot) ## [1] plot.acf* plot.data.frame* plot.decomposed.ts* ## [4] plot.default plot.dendrogram* plot.density* ## [7] plot.ecdf plot.factor* plot.formula* ## [10] plot.function plot.hclust* plot.histogram* ## [13] plot.HoltWinters* plot.isoreg* plot.lm* ## [16] plot.medpolish* plot.mlm* plot.ppr* ## [19] plot.prcomp* plot.princomp* plot.profile* ## [22] plot.profile.nls* plot.R6* plot.raster* ## [25] plot.spec* plot.stepfun plot.stl* ## [28] plot.table* plot.ts plot.tskernel* ## [31] plot.TukeyHSD* ## see &#39;?methods&#39; for accessing help and source code 8.1 Object and Class in R In R, everything is treated as an object, and many objects have associated attributes, including a class attribute. The class of an object defines how it is represented in the program. An object can have multiple classes, and you can modify its class using the class() function. The following example shows how to create an object of class foo. Note that in this example we use the attr() function to set the class attribute of the object. The function attr() deals with all kinds of attributes an object can have: class, dimensions, names, medatada, etc. x &lt;- 1 attr(x, &quot;class&quot;) &lt;- &quot;foo&quot; x ## [1] 1 ## attr(,&quot;class&quot;) ## [1] &quot;foo&quot; Or in one line, we can create and set the attribute class by using the structure() function: x &lt;- structure(1, class = &quot;foo&quot;) x ## [1] 1 ## attr(,&quot;class&quot;) ## [1] &quot;foo&quot; Class is stored as an attribute, but it’s better to modify it using the class() function, since this communicates your intent more clearly: class(x) &lt;- &quot;foo&quot; class(x) ## [1] &quot;foo&quot; You can use this approach to turn any object into an object of class “foo”, whether it makes sense or not. Objects are not limited to a single class, and can have many classes. While most programming languages have a single class system, R has at least three different class systems. Namely, S3, S4 and more recently R5 (Reference class) systems. We’ll explore two of them, the S3 and S4 classes. They have their own features and peculiarities and choosing one over the other is a matter of preference. Below, we give a brief introduction to them. 8.2 S3 Classes S3 class has no formal, predefined definition. For instance, a list with its class attribute set to some class name is an S3 object. The components of the list become the member variables of the object. Example Following is a simple example of how an S3 object of class student can be created. # create a list with required components s &lt;- list(name = &quot;John&quot;, age = 21, GPA = 3.5) # name the class appropriately class(s) &lt;- &quot;student&quot; # That&#39;s it! we now have an object of class &quot;student&quot; s ## $name ## [1] &quot;John&quot; ## ## $age ## [1] 21 ## ## $GPA ## [1] 3.5 ## ## attr(,&quot;class&quot;) ## [1] &quot;student&quot; 8.2.1 Methods and Generic Functions in S3 classes: Once the classes are defined we probably want to perform some computations on objects, implemented by the generic function. A generic function dispatches methods to objects in such as way that the same function performs different computations depending on the classes of its arguments. In the above example, when we simply write the name of the object, its internals get printed. s ## $name ## [1] &quot;John&quot; ## ## $age ## [1] 21 ## ## $GPA ## [1] 3.5 ## ## attr(,&quot;class&quot;) ## [1] &quot;student&quot; Furthermore, we can use the print() function, and the object/objects get printed differently according to the class they belong to. print(s) ## $name ## [1] &quot;John&quot; ## ## $age ## [1] 21 ## ## $GPA ## [1] 3.5 ## ## attr(,&quot;class&quot;) ## [1] &quot;student&quot; The print() function is a generic function. Actually, it has a collection of a number of methods. You can check all these methods with methods(print). methods(print) There are plenty of generic functions like print(). You can list them all with methods(class=\"default\"). Now let us implement a method print.student(): print.student &lt;- function(obj) { cat(obj$name, &quot;\\n&quot;) cat(obj$age, &quot;years old\\n&quot;) cat(&quot;GPA:&quot;, obj$GPA, &quot;\\n&quot;) } Now this method will be called whenever we print() an object of class “student”. In S3 system, methods do not belong to object or class, they belong to generic functions. This will work as long as the class of the object is set. s ## John ## 21 years old ## GPA: 3.5 Removing the class attribute will restore as previous unclass(s) ## $name ## [1] &quot;John&quot; ## ## $age ## [1] 21 ## ## $GPA ## [1] 3.5 It is also possible to make our own generic function like print() or plot(). Let us first look at how these functions are implemented and compare them to a non-generic function such as glm(). print ## function (x, ...) ## UseMethod(&quot;print&quot;) ## &lt;bytecode: 0x0000023e38630550&gt; ## &lt;environment: namespace:base&gt; glm ## function (formula, family = gaussian, data, weights, subset, ## na.action, start = NULL, etastart, mustart, offset, control = list(...), ## model = TRUE, method = &quot;glm.fit&quot;, x = FALSE, y = TRUE, singular.ok = TRUE, ## contrasts = NULL, ...) ## { ## cal &lt;- match.call() ## if (is.character(family)) ## family &lt;- get(family, mode = &quot;function&quot;, envir = parent.frame()) ## if (is.function(family)) ## family &lt;- family() ## if (is.null(family$family)) { ## print(family) ## stop(&quot;&#39;family&#39; not recognized&quot;) ## } ## if (missing(data)) ## data &lt;- environment(formula) ## mf &lt;- match.call(expand.dots = FALSE) ## m &lt;- match(c(&quot;formula&quot;, &quot;data&quot;, &quot;subset&quot;, &quot;weights&quot;, &quot;na.action&quot;, ## &quot;etastart&quot;, &quot;mustart&quot;, &quot;offset&quot;), names(mf), 0L) ## mf &lt;- mf[c(1L, m)] ## mf$drop.unused.levels &lt;- TRUE ## mf[[1L]] &lt;- quote(stats::model.frame) ## mf &lt;- eval(mf, parent.frame()) ## if (identical(method, &quot;model.frame&quot;)) ## return(mf) ## if (!is.character(method) &amp;&amp; !is.function(method)) ## stop(&quot;invalid &#39;method&#39; argument&quot;) ## if (identical(method, &quot;glm.fit&quot;)) ## control &lt;- do.call(&quot;glm.control&quot;, control) ## mt &lt;- attr(mf, &quot;terms&quot;) ## Y &lt;- model.response(mf, &quot;any&quot;) ## if (length(dim(Y)) == 1L) { ## nm &lt;- rownames(Y) ## dim(Y) &lt;- NULL ## if (!is.null(nm)) ## names(Y) &lt;- nm ## } ## X &lt;- if (!is.empty.model(mt)) ## model.matrix(mt, mf, contrasts) ## else matrix(, NROW(Y), 0L) ## weights &lt;- as.vector(model.weights(mf)) ## if (!is.null(weights) &amp;&amp; !is.numeric(weights)) ## stop(&quot;&#39;weights&#39; must be a numeric vector&quot;) ## if (!is.null(weights) &amp;&amp; any(weights &lt; 0)) ## stop(&quot;negative weights not allowed&quot;) ## offset &lt;- as.vector(model.offset(mf)) ## if (!is.null(offset)) { ## if (length(offset) != NROW(Y)) ## stop(gettextf(&quot;number of offsets is %d should equal %d (number of observations)&quot;, ## length(offset), NROW(Y)), domain = NA) ## } ## mustart &lt;- model.extract(mf, &quot;mustart&quot;) ## etastart &lt;- model.extract(mf, &quot;etastart&quot;) ## fit &lt;- eval(call(if (is.function(method)) &quot;method&quot; else method, ## x = X, y = Y, weights = weights, start = start, etastart = etastart, ## mustart = mustart, offset = offset, family = family, ## control = control, intercept = attr(mt, &quot;intercept&quot;) &gt; ## 0L, singular.ok = singular.ok)) ## if (length(offset) &amp;&amp; attr(mt, &quot;intercept&quot;) &gt; 0L) { ## fit2 &lt;- eval(call(if (is.function(method)) &quot;method&quot; else method, ## x = X[, &quot;(Intercept)&quot;, drop = FALSE], y = Y, mustart = fit$fitted.values, ## weights = weights, offset = offset, family = family, ## control = control, intercept = TRUE)) ## if (!fit2$converged) ## warning(&quot;fitting to calculate the null deviance did not converge -- increase &#39;maxit&#39;?&quot;) ## fit$null.deviance &lt;- fit2$deviance ## } ## if (model) ## fit$model &lt;- mf ## fit$na.action &lt;- attr(mf, &quot;na.action&quot;) ## if (x) ## fit$x &lt;- X ## if (!y) ## fit$y &lt;- NULL ## structure(c(fit, list(call = cal, formula = formula, terms = mt, ## data = data, offset = offset, control = control, method = method, ## contrasts = attr(X, &quot;contrasts&quot;), xlevels = .getXlevels(mt, ## mf))), class = c(fit$class, c(&quot;glm&quot;, &quot;lm&quot;))) ## } ## &lt;bytecode: 0x0000023e3c068af8&gt; ## &lt;environment: namespace:stats&gt; For the sake of example, we make a new generic function called grade. grade &lt;- function(obj) { UseMethod(&quot;grade&quot;) } A generic function is useless without any method. Let us implement the default method. grade.default &lt;- function(obj) { cat(&quot;This is a generic function\\n&quot;) } Now let us make method for our class “student”. grade.student &lt;- function(obj) { cat(&quot;Your grade is&quot;, obj$GPA, &quot;\\n&quot;) } In this way, we implemented a generic function called grade and later a method for our class. grade(s) ## Your grade is 3.5 Define a generic function is easy. All we need to do is to define a function with argument x (which is an object), and the body of the function is simply UseMethod(generic), where generic is character string. In general, the syntax of UseMethod is: UseMethod(generic, object) 8.3 S4 classes S4 classes in R provide a more formal and structured approach to object-oriented programming. S4 classes are explicitly defined using the setClass function, specifying slots (attributes) and their types. setClass(&quot;student&quot;, slots = c(name = &quot;character&quot;, age = &quot;numeric&quot;, GPA = &quot;numeric&quot;), prototype = list(name = NA_character_, age = NA_real_, GPA=NA_real_)) In this case, the class “student” has three slots with their specific data types. The argument prototype will define the default value for each slot when a new student object is created without specifying all the slots. For instance: new(&quot;student&quot;, name = &quot;Vero&quot;, GPA = 3.9) ## An object of class &quot;student&quot; ## Slot &quot;name&quot;: ## [1] &quot;Vero&quot; ## ## Slot &quot;age&quot;: ## [1] NA ## ## Slot &quot;GPA&quot;: ## [1] 3.9 8.3.1 Methods and Generic Functions in S4 classes: In S4, a generic function is explicitly defined using the setGeneric function. setGeneric(&quot;grade&quot;, function(object) standardGeneric(&quot;grade&quot;)) ## [1] &quot;grade&quot; Methods in S4 are explicitly defined using the setMethod function for a specific generic function and class. setMethod(&quot;grade&quot;, signature = &quot;student&quot;, function(object) { cat(&quot;Your grade is&quot;, object@GPA, &quot;\\n&quot;) }) Example: Let’s create an object of class “student” john &lt;- new(&quot;student&quot;, name = &quot;John&quot;, age = 25, GPA = 3.5) grade(john) ## Your grade is 3.5 Let’s add another method for the grade function, this time for a different class, say “employee”. setClass(&quot;employee&quot;, slots = c(name = &quot;character&quot;, age = &quot;numeric&quot;, salary = &quot;numeric&quot;)) Create an object of class “employee”: alice &lt;- new(&quot;employee&quot;, name = &quot;Alice&quot;, age = 30, salary = 50000) Define a method for the generic function “grade” and class “employee”: setMethod(&quot;grade&quot;, signature = &quot;employee&quot;, function(object) { cat(&quot;Employee&quot;, object@name, &quot;has an excellent work record.\\n&quot;) }) Call the generic function with objects of different classes: grade(john) ## Your grade is 3.5 grade(alice) ## Employee Alice has an excellent work record. "],["section-8.-dynamic-reports.html", "9 SECTION 8. Dynamic Reports 9.1 What is LATEX? 9.2 What is Sweave? 9.3 Basic options for code chunks 9.4 The Beamer class: LATEX presentations 9.5 Knitr package 9.6 R Markdown 9.7 Shiny 9.8 Quarto 9.9 Available templates for each block", " 9 SECTION 8. Dynamic Reports 9.1 What is LATEX? LATEX is different from other type setting systems in that you just have to tell it the logical and semantic structure of a text. It then derives the typographical form of the text according to the ‘rules’ given in the document class file and in various style files. LATEX allows users to structure their documents with a variety of hierarchical constructs, including chapters, sections, subsections and paragraphs. The standard document structure of a LATEX file includes the definition of the document class, where the document starts and ends. Additional information can include title, author(s) and affiliation of the author(s) as well as a table of content and different chapters and sections within the document. Figures, tables and a bibliography are also very common in most LATEX documents. The following code shows a basic LATEX document structure with title, table of contents and a section where the text of the document is entered. \\documentclass[11pt,a4paper,oneside]{report} \\begin{document} \\title{Basic \\LaTeX document structure with table of contents} \\author[1]{Your Name} \\affil[1]{Some Affiliation} \\maketitle \\tableofcontents \\section{Section Header} Some text. ... \\end{document} More details in: usrguide_latex.pdf 9.2 What is Sweave? A set of R functions, written by Friedrich Leisch (http://www.statistik.lmu.de/~leisch), working under one command in utils package Processes R code within a LaTex document Returns output from such code Creates plots and automatically creates the LaTex code for their inclusion A LaTex package and style (~.2.sty) 9.2.1 How to install Sweave Assuming LaTex and R are installed, there is no need for installation (in case you need to install LaTex: https://www.latex-project.org/get/) (https://tug.org/texlive/windows.html#install) Sweave is distributed with R (since version 1.5.0) It is included in the utils package (no need to load it) 9.2.1.1 An easy way is to run Sweave in Rstudio: open a new file from File, R Sweave just click on compile pdf button after you have edited the .Rnw file 9.2.1.2 How does it work? 9.2.1.2.1 The Noweb syntax: Code Chunks in Sweave To separate code and documentation chunks, the Noweb syntax is used Noweb is a literate programming tool which allows to combine program source code and the corresponding documentation into a single file Different segments are called chunks: &lt; &lt; options &gt; &gt;= denotes the start of code chunk, @ denotes the start of a documentation chunk. Two kind of operations: weave: typeset documentation together with code tangle: extract code chunks in a .R file &lt;&lt;chunkname&gt;&gt;= a &lt;- 1 b &lt;- 4 print(a+b) @ Each code chunk is translated into LATEX code by Sweave() as follows: \\begin{Schunk} \\begin{Sinput} &gt; a &lt;- 1 &gt; b &lt;- 4 &gt; print(a + b) \\end{Sinput} \\begin{Soutput} [1] 5 \\end{Soutput} \\end{Schunk} And finally after creating a pdf from the L ATEXdocument, the result in the pdf file is: &gt; a &lt;- 1 &gt; b &lt;- 4 &gt; print(a + b) [1] 5 9.2.1.3 The Sweave R package The Sweave package is part of the base installation of R (everybody should have it within the standard R installation), for more details see: help(&quot;Sweave&quot;, package = &quot;utils&quot;) The two main functions of the Sweave package are: Sweave(): Produces suitable documentation from the main source files. Rnw -&gt; tex Stangle(): Produces programming code from the main source files. Rnw -&gt; R 9.3 Basic options for code chunks Multiple options can be placed in the construct &lt;&lt;&gt;&gt;= to control how the code in the chunks is executed (bold means default setting): eval (TRUE, FALSE): Whether the R chunk is run. If FALSE, the code chunk is not evaluated, and hence no text or graphical output produced (default is TRUE). echo (TRUE, FALSE): Whether the R chunk is shown in the LATEX file (default is FALSE) results (verbatim, tex, hide): Type of output used to show the printed results produced by the R code. ‘hide’ will show no output at all (default is verbatim). fig: (TRUE, FALSE): If TRUE it includes the plot created in the code (default is FALSE). width: numeric, width of figures in inch height: numeric, height of figures in inch 9.3.1 For costly computations: cacheSweave package Add cache=TRUE to computationally expensive chunks After the first run, objects from the cached chunks keep stored in a hash map Subsequent Sweaves do not evaluate these chunks Cached chunks must be computations only (NO FIGURES) Options can be set globally at the beginning of the file (and changed everywhere else) with \\SweaveOpts{option1,option2,...} 9.3.2 Example We created a code chunk named summaryFUN with no additional options set. Hence, the R code is executed and displayed as code insight a verbatim environment in LATEX: &lt;&lt;summaryFUN&gt;&gt;= custom.summary &lt;- function(x) { return(list(Mean = mean(x), Max = max(x), Min = min(x), Summary = summary(x), Head = head(x), Class = class(x), Length = length(x))) } @ Now the custom.summary function is created in our R environment and can be called in following code chunks. For instance, we take the cars data that is included in the R base installation. The cars object includes the data of speed and the distances taken to stop of cars. &lt;&lt;chunkresults&gt;&gt;= result &lt;- custom.summary(cars$speed) result @ The custom.summary function returns a list that is stored into the result object and printed out. Going to more advanced Sweave use cases, we can define our own plotting function or use existing once (for example plot(), hist(), boxplot(), …) to integrate figures in our document. For a simple example we use another car dataset that is included in the R base installation which includes a table of 11 aspects of automobile design and performance for 32 cars from 1973-1974. A histogram plot of the miles per gallon data for the 32 cars results in: &lt;&lt;chunkgraph&gt;&gt;= hist(mtcars$mpg) @ Sweave and R also allow displaying tables in the document and creating these directly from for example a data frame or matrix. Therefor we have to load the xtable package in R, create the LATEX code with xtable() and set the results option to tex to directly get LATEX code without interpreting it from Sweave. &lt;&lt;chunktable&gt;&gt;= library(xtable) texTable &lt;- sapply(mtcars, function(x) summary(x)) xtable(texTable) @ 9.4 The Beamer class: LATEX presentations Beamer is a LATEX class for creating presentations. 9.4.1 Table of Contents \\begin{frame} \\frametitle{Outline} \\end{frame} 9.4.2 Sections and Subsections \\section{Motivation} \\subsection{The Basic Problem That We Studied} Notice that these commands are given outside of frames. 9.4.3 Frames and structures: Presentations are divided in frames. Each frame can be generated as follow: \\begin{frame} \\frametitle{What Are Prime Numbers?} A prime number is a number that has exactly two divisors. \\end{frame} We can structure frames in block environments: \\begin{frame} \\frametitle{What&#39;s Still To Do?} \\begin{block}{Answered Questions} How many primes are there? \\end{block} \\begin{block}{Open Questions} Is every even number the sum of two primes? \\end{block} \\end{frame} An alternative way to structure our frames is the itemize statement: \\begin{frame} \\frametitle{What&#39;s Still To Do?} \\begin{itemize} \\item Answered Questions \\begin{itemize} \\item How many primes are there? \\end{itemize} \\item Open Questions \\begin{itemize} \\item Is every even number the sum of two primes? \\end{itemize} \\end{itemize} \\end{frame} Example: Creating a Beamer Presentation Structure Your Presentation \\documentclass{beamer} % This is the file main.tex \\usetheme{Berlin} \\title{Example Presentation Created with the Beamer Package} \\author{Till Tantau} \\date{\\today} \\begin{document} \\begin{frame} \\titlepage \\end{frame} \\section*{Outline} \\begin{frame} \\tableofcontents \\end{frame} \\section{Introduction} \\subsection{Overview of the Beamer Class} \\subsection{Overview of Similar Classes} \\section{Usage} \\subsection{...} \\subsection{...} \\section{Examples} \\subsection{...} \\subsection{...} \\begin{frame} ... \\end{frame} % to enforce entries in the table of contents \\end{document} Create Frames: Once the table of contents looks satisfactory, start creating frames for your presentation by adding frame environments: The Frame Title: Put a title on each frame. Structuring a Frame: Use block environments like block, theorem, proof, example, and so on Writing the Text Using Graphs: \\includegraphics[scale=1]{file.png} Choosing Appropriate Themes and colors: http://deic.uab.es/~iblanes/beamer_gallery/ Creating a PDF or PostScript File presentation. More details in: beameruserguide.pdf. You can also check the code of different beamer templates in overleaf: https://www.overleaf.com/project/63542ffd4269fe31b95215c3 https://www.overleaf.com/learn/latex/Beamer. 9.5 Knitr package Prettier out of the box (than Sweave) Code re-formating: use option tidy. Code highlighting (with Sweave too but you need a xycolor.sty file in your latex distribution). Simple copy-paste enabled. Better approach to dealing with plots (for example fig.keep option for more than 2 plots in 1 chunk). 9.5.1 Knitr main outputs HTML: via R Markdown files (Rmd). PDF: mostly through Rnw files or via latex conversion using in R the pandoc('namefile', format='latex') command. 9.6 R Markdown The rmarkdown package is a next generation implementation of R Markdown based on pandoc. This implementation brings many enhancements to R Markdown, including: Create HTML, PDF, and MS Word documents as well as Beamer, ioslides, and Slidy presentations. New markdown syntax including expanded support for tables, definition lists, and bibliographies. Hooks for customizing HTML and PDF output (include CSS, headers, and footers). Include raw LaTeX within markdown for advanced customization of PDF output. Compile HTML, PDF, or MS Word notebooks from R scripts. Extensibility: easily define new formats for custom publishing requirements. Create interactive R Markdown documents using Shiny. 9.6.1 Installation If you are working within RStudio then you can simply install the current release of RStudio (both the rmarkdown package and pandoc are included). If you want to use the rmarkdown package outside of RStudio then you can install the package from CRAN as follows: install.packages(&quot;rmarkdown&quot;) A recent version of pandoc (&gt;= 1.12.3) is also required. See the pandoc installation instructions for details on installing pandoc for your platform. 9.6.2 Output Formats R Markdown documents can contain a metadata section that includes both title, author, and date information as well as options for customizing output. For example, this metadata included at the top of an Rmd file adds a table of contents and chooses a different HTML theme: --- title: &quot;Sample Document&quot; output: html_document: toc: true theme: united --- R Markdown has built in support for several output formats (HTML, PDF, and MS Word documents as well as Beamer presentations). These formats can also be specified in metadata, for example: --- title: &quot;Sample Document&quot; output: pdf_document: toc: true highlight: zenburn --- If you aren’t specifying format options you can also just use a simple format name: --- title: &quot;Sample Document&quot; output: pdf_document --- Multiple formats can be specified in metadata: --- title: &quot;Sample Document&quot; output: html_document: toc: true theme: united pdf_document: toc: true highlight: zenburn --- 9.6.3 Output Format Functions Output formats need not be specified in metadata. In fact, metadata is just a convenient way to invoke functions that implement output formats. There are seven built-in output formats each exported as a function from the package: html_document pdf_document word_document md_document beamer_presentation ioslides_presentation slidy_presentation 9.6.4 Chunk Options Common: eval (TRUE, FALSE): Whether the R chunk is run. If FALSE, the code chunk is not evaluated, and hence no text or graphical output produced (default is TRUE). echo (TRUE, FALSE): Whether the R chunk is shown in the LATEX file (default is FALSE). fig.width, fig.height: R control. Figure: fig.width, fig.height: R control. out.width, out.height: output control. fig.keep: for more than 2 plots in 1 chunk. fig.cap: caption in Rnw only. More details in: rmarkdown-reference.pdf 9.7 Shiny Shiny is an R package that makes easy to build interactive web applications straight from R. First of all, we need to install the Shiny package in R install.packages(\"shiny\") This package has different examples where each one of them is a self-contained Shinny app. We will look at first at Hello Shiny example, that works with the dataset faithful. app.R: to take a look to the main code. In the following link we can access different examples: https://shiny.rstudio.com/tutorial/written-tutorial/lesson1/ Reactivity Run example 3 - runExample(\"03_reactivity\") Global variables Run example 4- runExample(\"04_mpg\") In case you want to visualize some applications, you can also access the following link: https://shiny.rstudio.com/gallery/ Moreover, there is a new resource that allows the user to directly create the structure of the shinny app through an interactive editor: https://rstudio.github.io/shinyuieditor/. To use it we should follow the following steps: 1- Download the remotes apckage and upload it: install.packages(\"remotes\") and library(remotes). 2- Download the shinyuieditor package from github and upload it: remotes::install_github(\"rstudio/shinyuieditor\") and library(shinyuieditor). 3- Create a new app using the editor and see how it creates the code directly to a new R script called app.R: setwd(path/to/file) shinyuieditor::launch_editor(app_loc = \"Launch_app/\") 9.8 Quarto Includes new features and capabilities while at the same time being able to render most existing Rmd files without modification. Quarto is open source, and it’s as friendly to Python, Julia, Observable JavaScript, and Jupyter notebooks as it is to R. It’s not a language-specific library (as R Markdown), but an external software application. Different from R Markdown, in Quarto chunk options are typically included in special comments at the top of code chunks rather than within the line that begins the chunk: #| echo: false #| fig-cap: &quot;Air Quality&quot; #| warning: false Similar to R Markdown, the rendered version is viewed as HTML. We can also choose to render it into other formats like PDF, MS Word, etc. What can we do with Quarto? books websites blogs In this section, we’ll show how to use it in RStudio. We will learn how to edit code just as we would do with any computational document (e.g. R Markdown), and preview the rendered document in the Viewer tab as we work. Link to download a .qmd file (Quarto document): https://quarto.org/docs/get-started/hello/rstudio.html When we render a Quarto document: Knitr executes all of the code chunks It creates a new markdown (.md) document that includes the code and its output The markdown file is processed by pandoc: it creates the finished format. 9.9 Available templates for each block You will find them in the moodle, link - Sweave: Sweave.Rnwcontains the code; Sweave.pdfcontains the output. - Markdown: HTML: Rmarkdown_html.RMD contains the code; Rmarkdown_html.hmtl contains the output. PDF: Rmarkdown_pdf.RMD contains the code; Rmarkdown_pdf.pdf contains the output. WORD: Rmarkdown_word.RMD contains the code; Rmarkdown_word.docx contains the output. - Beamer: with Sweave: Beamer.RNW contains the code; Beamer.pdf contains the output. with Markdown: Beamer_markdown.RMD contains the code; Beamer_markdown.pdf contains the output. - Quarto: quarto.QMD contains the code; quarto.html contains the output. - Shiny: app.R contains the code; we need to run the app to visualize the output. "],["section-9.-data-managment-using-the-dplyr-package.html", "10 SECTION 9. Data managment using the dplyr package 10.1 The filter() function and the use of comparison operators 10.2 Sorting with arrange() 10.3 Accessing rows with slice() 10.4 Picking columns out with select() 10.5 Change names with rename() 10.6 Transforming pre-existing columns or creating new ones with mutate() 10.7 To sum up…group_by() + summarise() 10.8 Data reshaping and cleaning using the tidyr package 10.9 Gt and gtsummary packages 10.10 Exercises", " 10 SECTION 9. Data managment using the dplyr package The dplyr and tidyr packages are part of tidyverse, a “grammar of data manipulation”. The tidyverse comprises a collection of R packages specifically designed for data science including, among others, ggplot2 (Check tidyverse website and this free online book for useful tutorials: “R for Data Science”). dplyr is primarily focused on data manipulation tasks. It provides functions for filtering, selecting, mutating, arranging, and summarizing data. The package is designed to make data wrangling operations fast and intuitive. tidyr is focused on reshaping and cleaning data. It provides functions to organize and transform data into a “tidy” format, where each variable is in its own column, each observation is in its own row, and each value is in its own cell. To install the whole tidyverse: install.packages(\"tidyverse\"). To install just dplyr: install.packages(\"dplyr\"). For bug fixing or to use a tool in development: install.packages(\"devtools\") and install_github(\"tidyverse/dplyr\"). The dplyr package contains very convenient functions for data manipulation which “translate” some Base R functions that we explored in Lesson 2 such as subset(), which(), order() or within(). These functions process data faster than Base R functions and transform your scripts into more “readable” coding. These are some of the most important functions included in dplyr package: To work with… Functions in dplyr package To… Base R functions Rows filter() pick rows based on their values which(); subset() Rows arrange() sort rows order() Rows slice() pick rows based on location [RowPosition,] Rows recode() recode dummy/encoded variables comparison operators Columns select() include/exclude columns [, \"ColumnName\"]; subset(..., select()) Columns rename() change name of columns colnames(); names() Columns mutate() change/create columns within() Columns relocate() change columns’ order [ , NewColumnPosition ] Columns group_by() + summarise() collapse into a single row mean(); median(); ... One of the most useful functions to use together with the above functions is group_by() (it’s equivalent to GROUP BY in SQL). With this function we will applied the functions only to previously created groups based on one or more columns in the dataset. Now, it’s time to play a little bit with these functions! First, we will load a dataframe that you will find in the following link. data&lt;- read.table(file = &quot;./dataset_class.txt&quot;,header = T, sep = &quot;\\t&quot;) We are working with a dataset that contains information of 300 individuals for which we have available information for 8 different variables. 10.1 The filter() function and the use of comparison operators Filter rows based on column values. Similar to what we did with which() or subset(), we can implement comparison operators to this function (e.g &lt;, &gt;, !=). For instance, how many individuals are older than 30 and display glucose levels above 65? And how many of them are also women? filter1&lt;- dplyr::filter(data,Age &gt;30,Glucose &gt;65) filter2&lt;- dplyr::filter(data,Age &gt;30,Glucose &gt;65, Sex==&quot;Women&quot;) 10.2 Sorting with arrange() Sort rows by ascending or descending order. We can reorder the data.frame based on one or more columns. For instance, for sorting our data based on increasing “Age” of individuals we will use: df_sorted&lt;- arrange(data, Age, Cholesterol) 10.3 Accessing rows with slice() It allows to access rows by their indexes (i.e. integer location). slice(data, 5:10) ## Sex Age BMI SBP HADS_Anxiety Cholesterol Glucose Family_History_CVD ## 1 Women 34 19.8 166 7 178.4 95.2 No ## 2 Men 46 34.8 120 0 187.7 129.7 No ## 3 Men 43 28.1 133 13 262.9 113.2 No ## 4 Men 44 27.8 133 10 232.7 83.7 No ## 5 Women 38 18.2 144 21 165.6 91.3 No ## 6 Women 24 29.4 121 10 138.4 114.6 No 10.4 Picking columns out with select() We can use select()to subset columns using their specific names or properties (type numeric, character, factor). We can combine the use of select()with Base R operators (i.e. :, !,&amp;,c()) and selection helpers. Some of the most interesting helpers are those which allow the selection of variables according to a given pattern: starts_with(), ends_with(), contains(), matches(), num_range(). Some examples: select(data, c(Sex, starts_with(&quot;Glu&quot;))) select(data, c(Age, starts_with(&quot;Chol&quot;))) 10.5 Change names with rename() This function facilities the readability of datasets (i.e. change encoded columns) or make it easy to correct errors in the name of the columns. rename(data,Family_History=Family_History_CVD) 10.6 Transforming pre-existing columns or creating new ones with mutate() mutate(data, RandomVariable = SBP + Cholesterol) 10.7 To sum up…group_by() + summarise() group_by(data, Sex) %&gt;% summarise(Mean_SBP = mean(SBP,na.rm=T)) ## # A tibble: 2 × 2 ## Sex Mean_SBP ## &lt;chr&gt; &lt;dbl&gt; ## 1 Men 120. ## 2 Women 120. We have already incorporated the use of “the pipe, %&gt;%”. The main advantage of using dplyr for data management is that this package offers a very convenient tool to concatenate several operations. So, the whole point of dplyr is to make several transformation in your data at once. data %&gt;% filter(Sex==&quot;Women&quot;) %&gt;% group_by(Family_History_CVD) %&gt;% summarise(Mean_Age = mean(Age,na.rm=T), Mean_cholesterol = mean(Cholesterol, na.rm=T), count_BMIobese = sum(BMI&gt;28)) ## # A tibble: 2 × 4 ## Family_History_CVD Mean_Age Mean_cholesterol count_BMIobese ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 No 48.6 201. 21 ## 2 Yes 48.7 198. 8 10.8 Data reshaping and cleaning using the tidyr package Similarly, with tidyr we can also work with functions that process data faster than Base R functions. These are some of the most important functions included in tidyr package: To work with… Functions in tidyr package To… Base R functions Columns pivot_longer() convert wide data to long format reshape(); stack() Columns pivot_wider() convert long data to wide format reshape(); unstack() Columns separate() split one column into multiple columns strsplit() Columns unite() combine multiple columns into one paste(); paste0() Missing Values fill() fill missing values in a column na.locf() from zoo package Missing Values replace_na() replace missing values with specified values is.na(); ifelse() Columns drop_na() remove rows with missing values na.omit(); complete.cases() Rows expand() create all combinations of values expand.grid() Rows complete() complete missing combinations of values expand.grid(); merge() Rows/Columns nest() create nested data frames list() Rows/Columns unnest() expand a list-column into multiple rows do.call(rbind, ...) 10.8.1 Transforming wide to long format with pivot_longer(): We want to put the information for the variable BMI, Cholesterol and Glucose in a long format. library(tidyr) head(data) ## Sex Age BMI SBP HADS_Anxiety Cholesterol Glucose Family_History_CVD ## 1 Women 43 23.1 129 5 223.3 87.2 No ## 2 Women 59 28.4 154 12 183.4 83.1 No ## 3 Women 66 28.7 105 11 266.8 87.8 No ## 4 Men 75 23.7 122 2 221.4 64.2 No ## 5 Women 34 19.8 166 7 178.4 95.2 No ## 6 Men 46 34.8 120 0 187.7 129.7 No long_format &lt;- data %&gt;% pivot_longer(cols = c(BMI, Cholesterol, Glucose), names_to = &quot;Measurement_Type&quot;, values_to = &quot;Value&quot;) head(long_format) ## # A tibble: 6 × 7 ## Sex Age SBP HADS_Anxiety Family_History_CVD Measurement_Type Value ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Women 43 129 5 No BMI 23.1 ## 2 Women 43 129 5 No Cholesterol 223. ## 3 Women 43 129 5 No Glucose 87.2 ## 4 Women 59 154 12 No BMI 28.4 ## 5 Women 59 154 12 No Cholesterol 183. ## 6 Women 59 154 12 No Glucose 83.1 10.8.2 Transforming long to wide format with pivot_wider(): In this example, we use the long_format object generated in the previous example to re-convert it again to wide format. # Suppose we have a column &quot;Measurement_Type&quot; with values for &quot;Cholesterol&quot; and &quot;Glucose&quot; # Transform it back to wide format head(long_format) ## # A tibble: 6 × 7 ## Sex Age SBP HADS_Anxiety Family_History_CVD Measurement_Type Value ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Women 43 129 5 No BMI 23.1 ## 2 Women 43 129 5 No Cholesterol 223. ## 3 Women 43 129 5 No Glucose 87.2 ## 4 Women 59 154 12 No BMI 28.4 ## 5 Women 59 154 12 No Cholesterol 183. ## 6 Women 59 154 12 No Glucose 83.1 wide_format &lt;- long_format %&gt;% pivot_wider(names_from = Measurement_Type, values_from = Value) head(wide_format) ## # A tibble: 6 × 8 ## Sex Age SBP HADS_Anxiety Family_History_CVD BMI Cholesterol Glucose ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Women 43 129 5 No 23.1 223. 87.2 ## 2 Women 59 154 12 No 28.4 183. 83.1 ## 3 Women 66 105 11 No 28.7 267. 87.8 ## 4 Men 75 122 2 No 23.7 221. 64.2 ## 5 Women 34 166 7 No 19.8 178. 95.2 ## 6 Men 46 120 0 No 34.8 188. 130. 10.8.3 Handling missing values with replace_na() We create a new random variable that will take NA values for those cases where cholesterol is above 230 and then we will replace it with the median value. # Replace NA values in Cholesterol with the median Cholesterol table(is.na(data$Cholesterol)) ## ## FALSE ## 300 summary(data$Cholesterol) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 122.7 180.2 200.0 200.6 222.6 280.0 data&lt;- data %&gt;% mutate(Variable_Nas=ifelse(Cholesterol &gt; 230, NA, Cholesterol)) summary(data$Variable_Nas) ## Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s ## 122.7 173.9 193.4 190.8 208.8 229.0 55 data &lt;- data %&gt;% mutate(Variable_Nas = replace_na(Variable_Nas, median(Cholesterol, na.rm = TRUE))) summary(data$Variable_Nas) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 122.7 180.2 200.0 192.5 204.9 229.0 10.9 Gt and gtsummary packages 10.9.1 Basic Summary Table with tbl_summary() The tbl_summary() function calculates descriptive statistics for continuous, categorical, and dichotomous variables in R, and presents the results in a beautiful, customizable summary table ready for publication library(gtsummary) library(gt) data %&gt;% tbl_summary( by = Sex, # Summarize separately for Men and Women missing = &quot;no&quot; # Exclude missing values in summary ) %&gt;% as_gt() #yypurbehai table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #yypurbehai thead, #yypurbehai tbody, #yypurbehai tfoot, #yypurbehai tr, #yypurbehai td, #yypurbehai th { border-style: none; } #yypurbehai p { margin: 0; padding: 0; } #yypurbehai .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #yypurbehai .gt_caption { padding-top: 4px; padding-bottom: 4px; } #yypurbehai .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #yypurbehai .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #yypurbehai .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #yypurbehai .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #yypurbehai .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #yypurbehai .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #yypurbehai .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #yypurbehai .gt_column_spanner_outer:first-child { padding-left: 0; } #yypurbehai .gt_column_spanner_outer:last-child { padding-right: 0; } #yypurbehai .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #yypurbehai .gt_spanner_row { border-bottom-style: hidden; } #yypurbehai .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #yypurbehai .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #yypurbehai .gt_from_md > :first-child { margin-top: 0; } #yypurbehai .gt_from_md > :last-child { margin-bottom: 0; } #yypurbehai .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #yypurbehai .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #yypurbehai .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #yypurbehai .gt_row_group_first td { border-top-width: 2px; } #yypurbehai .gt_row_group_first th { border-top-width: 2px; } #yypurbehai .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #yypurbehai .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #yypurbehai .gt_first_summary_row.thick { border-top-width: 2px; } #yypurbehai .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #yypurbehai .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #yypurbehai .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #yypurbehai .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #yypurbehai .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #yypurbehai .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #yypurbehai .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #yypurbehai .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #yypurbehai .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #yypurbehai .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #yypurbehai .gt_left { text-align: left; } #yypurbehai .gt_center { text-align: center; } #yypurbehai .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #yypurbehai .gt_font_normal { font-weight: normal; } #yypurbehai .gt_font_bold { font-weight: bold; } #yypurbehai .gt_font_italic { font-style: italic; } #yypurbehai .gt_super { font-size: 65%; } #yypurbehai .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #yypurbehai .gt_asterisk { font-size: 100%; vertical-align: 0; } #yypurbehai .gt_indent_1 { text-indent: 5px; } #yypurbehai .gt_indent_2 { text-indent: 10px; } #yypurbehai .gt_indent_3 { text-indent: 15px; } #yypurbehai .gt_indent_4 { text-indent: 20px; } #yypurbehai .gt_indent_5 { text-indent: 25px; } #yypurbehai .katex-display { display: inline-flex !important; margin-bottom: 0.75em !important; } #yypurbehai div.Reactable > div.rt-table > div.rt-thead > div.rt-tr.rt-tr-group-header > div.rt-th-group:after { height: 0px !important; } Characteristic Men N = 1461 Women N = 1541 Age 50 (35, 65) 49 (34, 64) BMI 25.4 (22.7, 27.4) 24.1 (21.5, 27.3) SBP 120 (109, 131) 120 (112, 130) HADS_Anxiety 10 (5, 16) 11 (5, 16) Cholesterol 199 (180, 225) 200 (180, 221) Glucose 100 (84, 112) 97 (85, 109) Family_History_CVD 34 (23%) 53 (34%) Variable_Nas 199 (180, 203) 200 (180, 207) 1 Median (Q1, Q3); n (%) 10.9.2 Adding statistical tests with add_p() data %&gt;% tbl_summary(by = Sex) %&gt;% add_p() # Adds p-values for group comparisons #mzsxmcwcpa table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #mzsxmcwcpa thead, #mzsxmcwcpa tbody, #mzsxmcwcpa tfoot, #mzsxmcwcpa tr, #mzsxmcwcpa td, #mzsxmcwcpa th { border-style: none; } #mzsxmcwcpa p { margin: 0; padding: 0; } #mzsxmcwcpa .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #mzsxmcwcpa .gt_caption { padding-top: 4px; padding-bottom: 4px; } #mzsxmcwcpa .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #mzsxmcwcpa .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #mzsxmcwcpa .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #mzsxmcwcpa .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #mzsxmcwcpa .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #mzsxmcwcpa .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #mzsxmcwcpa .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #mzsxmcwcpa .gt_column_spanner_outer:first-child { padding-left: 0; } #mzsxmcwcpa .gt_column_spanner_outer:last-child { padding-right: 0; } #mzsxmcwcpa .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #mzsxmcwcpa .gt_spanner_row { border-bottom-style: hidden; } #mzsxmcwcpa .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #mzsxmcwcpa .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #mzsxmcwcpa .gt_from_md > :first-child { margin-top: 0; } #mzsxmcwcpa .gt_from_md > :last-child { margin-bottom: 0; } #mzsxmcwcpa .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #mzsxmcwcpa .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #mzsxmcwcpa .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #mzsxmcwcpa .gt_row_group_first td { border-top-width: 2px; } #mzsxmcwcpa .gt_row_group_first th { border-top-width: 2px; } #mzsxmcwcpa .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #mzsxmcwcpa .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #mzsxmcwcpa .gt_first_summary_row.thick { border-top-width: 2px; } #mzsxmcwcpa .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #mzsxmcwcpa .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #mzsxmcwcpa .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #mzsxmcwcpa .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #mzsxmcwcpa .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #mzsxmcwcpa .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #mzsxmcwcpa .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #mzsxmcwcpa .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #mzsxmcwcpa .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #mzsxmcwcpa .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #mzsxmcwcpa .gt_left { text-align: left; } #mzsxmcwcpa .gt_center { text-align: center; } #mzsxmcwcpa .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #mzsxmcwcpa .gt_font_normal { font-weight: normal; } #mzsxmcwcpa .gt_font_bold { font-weight: bold; } #mzsxmcwcpa .gt_font_italic { font-style: italic; } #mzsxmcwcpa .gt_super { font-size: 65%; } #mzsxmcwcpa .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #mzsxmcwcpa .gt_asterisk { font-size: 100%; vertical-align: 0; } #mzsxmcwcpa .gt_indent_1 { text-indent: 5px; } #mzsxmcwcpa .gt_indent_2 { text-indent: 10px; } #mzsxmcwcpa .gt_indent_3 { text-indent: 15px; } #mzsxmcwcpa .gt_indent_4 { text-indent: 20px; } #mzsxmcwcpa .gt_indent_5 { text-indent: 25px; } #mzsxmcwcpa .katex-display { display: inline-flex !important; margin-bottom: 0.75em !important; } #mzsxmcwcpa div.Reactable > div.rt-table > div.rt-thead > div.rt-tr.rt-tr-group-header > div.rt-th-group:after { height: 0px !important; } Characteristic Men N = 1461 Women N = 1541 p-value2 Age 50 (35, 65) 49 (34, 64) 0.5 BMI 25.4 (22.7, 27.4) 24.1 (21.5, 27.3) 0.088 SBP 120 (109, 131) 120 (112, 130) 0.8 HADS_Anxiety 10 (5, 16) 11 (5, 16) 0.9 Cholesterol 199 (180, 225) 200 (180, 221) >0.9 Glucose 100 (84, 112) 97 (85, 109) 0.6 Family_History_CVD 34 (23%) 53 (34%) 0.034 Variable_Nas 199 (180, 203) 200 (180, 207) 0.6 1 Median (Q1, Q3); n (%) 2 Wilcoxon rank sum test; Pearson’s Chi-squared test 10.9.3 Stratified Tables with tbl_strata() data %&gt;% tbl_strata( strata = Family_History_CVD, # Stratify by family history of CVD .tbl_fun = ~ .x %&gt;% tbl_summary(by = Sex) ) #uuylmtiuvo table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #uuylmtiuvo thead, #uuylmtiuvo tbody, #uuylmtiuvo tfoot, #uuylmtiuvo tr, #uuylmtiuvo td, #uuylmtiuvo th { border-style: none; } #uuylmtiuvo p { margin: 0; padding: 0; } #uuylmtiuvo .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #uuylmtiuvo .gt_caption { padding-top: 4px; padding-bottom: 4px; } #uuylmtiuvo .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #uuylmtiuvo .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #uuylmtiuvo .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #uuylmtiuvo .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #uuylmtiuvo .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #uuylmtiuvo .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #uuylmtiuvo .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #uuylmtiuvo .gt_column_spanner_outer:first-child { padding-left: 0; } #uuylmtiuvo .gt_column_spanner_outer:last-child { padding-right: 0; } #uuylmtiuvo .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #uuylmtiuvo .gt_spanner_row { border-bottom-style: hidden; } #uuylmtiuvo .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #uuylmtiuvo .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #uuylmtiuvo .gt_from_md > :first-child { margin-top: 0; } #uuylmtiuvo .gt_from_md > :last-child { margin-bottom: 0; } #uuylmtiuvo .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #uuylmtiuvo .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #uuylmtiuvo .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #uuylmtiuvo .gt_row_group_first td { border-top-width: 2px; } #uuylmtiuvo .gt_row_group_first th { border-top-width: 2px; } #uuylmtiuvo .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #uuylmtiuvo .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #uuylmtiuvo .gt_first_summary_row.thick { border-top-width: 2px; } #uuylmtiuvo .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #uuylmtiuvo .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #uuylmtiuvo .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #uuylmtiuvo .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #uuylmtiuvo .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #uuylmtiuvo .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #uuylmtiuvo .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #uuylmtiuvo .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #uuylmtiuvo .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #uuylmtiuvo .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #uuylmtiuvo .gt_left { text-align: left; } #uuylmtiuvo .gt_center { text-align: center; } #uuylmtiuvo .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #uuylmtiuvo .gt_font_normal { font-weight: normal; } #uuylmtiuvo .gt_font_bold { font-weight: bold; } #uuylmtiuvo .gt_font_italic { font-style: italic; } #uuylmtiuvo .gt_super { font-size: 65%; } #uuylmtiuvo .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #uuylmtiuvo .gt_asterisk { font-size: 100%; vertical-align: 0; } #uuylmtiuvo .gt_indent_1 { text-indent: 5px; } #uuylmtiuvo .gt_indent_2 { text-indent: 10px; } #uuylmtiuvo .gt_indent_3 { text-indent: 15px; } #uuylmtiuvo .gt_indent_4 { text-indent: 20px; } #uuylmtiuvo .gt_indent_5 { text-indent: 25px; } #uuylmtiuvo .katex-display { display: inline-flex !important; margin-bottom: 0.75em !important; } #uuylmtiuvo div.Reactable > div.rt-table > div.rt-thead > div.rt-tr.rt-tr-group-header > div.rt-th-group:after { height: 0px !important; } Characteristic No Yes Men N = 1121 Women N = 1011 Men N = 341 Women N = 531 Age 50 (36, 66) 48 (34, 65) 46 (34, 62) 50 (35, 58) BMI 25.3 (22.5, 27.5) 24.5 (21.7, 27.5) 25.5 (22.8, 27.3) 23.8 (21.0, 25.8) SBP 120 (109, 130) 120 (110, 130) 120 (111, 133) 120 (113, 130) HADS_Anxiety 10 (5, 16) 11 (5, 16) 10 (6, 18) 11 (5, 18) Cholesterol 201 (181, 226) 201 (185, 218) 197 (179, 212) 200 (171, 228) Glucose 102 (85, 113) 95 (84, 106) 97 (82, 109) 102 (87, 115) Variable_Nas 200 (181, 203) 200 (185, 207) 197 (179, 204) 200 (171, 206) 1 Median (Q1, Q3) #~ .x %&gt;% tbl_summary(by = Sex) is a shortcut syntax in R for defining an anonymous (or lambda) function. # This is equivalent to writing function(.x) .x %&gt;% tbl_summary(by = Sex). #In this context, .x represents each subset of the data created by the stratification. #tbl_summary(by = Sex) is applied to each subset, creating a summary table for each stratified group. 10.9.4 Creating Cross Tables with tbl_cross() You can create cross-tabulations, similar to contingency tables. table(data$Sex, data$Family_History_CVD) ## ## No Yes ## Men 112 34 ## Women 101 53 data %&gt;% tbl_cross( row = Sex, col = Family_History_CVD ) #mcuiujdfax table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #mcuiujdfax thead, #mcuiujdfax tbody, #mcuiujdfax tfoot, #mcuiujdfax tr, #mcuiujdfax td, #mcuiujdfax th { border-style: none; } #mcuiujdfax p { margin: 0; padding: 0; } #mcuiujdfax .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #mcuiujdfax .gt_caption { padding-top: 4px; padding-bottom: 4px; } #mcuiujdfax .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #mcuiujdfax .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #mcuiujdfax .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #mcuiujdfax .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #mcuiujdfax .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #mcuiujdfax .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #mcuiujdfax .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #mcuiujdfax .gt_column_spanner_outer:first-child { padding-left: 0; } #mcuiujdfax .gt_column_spanner_outer:last-child { padding-right: 0; } #mcuiujdfax .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #mcuiujdfax .gt_spanner_row { border-bottom-style: hidden; } #mcuiujdfax .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #mcuiujdfax .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #mcuiujdfax .gt_from_md > :first-child { margin-top: 0; } #mcuiujdfax .gt_from_md > :last-child { margin-bottom: 0; } #mcuiujdfax .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #mcuiujdfax .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #mcuiujdfax .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #mcuiujdfax .gt_row_group_first td { border-top-width: 2px; } #mcuiujdfax .gt_row_group_first th { border-top-width: 2px; } #mcuiujdfax .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #mcuiujdfax .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #mcuiujdfax .gt_first_summary_row.thick { border-top-width: 2px; } #mcuiujdfax .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #mcuiujdfax .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #mcuiujdfax .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #mcuiujdfax .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #mcuiujdfax .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #mcuiujdfax .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #mcuiujdfax .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #mcuiujdfax .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #mcuiujdfax .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #mcuiujdfax .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #mcuiujdfax .gt_left { text-align: left; } #mcuiujdfax .gt_center { text-align: center; } #mcuiujdfax .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #mcuiujdfax .gt_font_normal { font-weight: normal; } #mcuiujdfax .gt_font_bold { font-weight: bold; } #mcuiujdfax .gt_font_italic { font-style: italic; } #mcuiujdfax .gt_super { font-size: 65%; } #mcuiujdfax .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #mcuiujdfax .gt_asterisk { font-size: 100%; vertical-align: 0; } #mcuiujdfax .gt_indent_1 { text-indent: 5px; } #mcuiujdfax .gt_indent_2 { text-indent: 10px; } #mcuiujdfax .gt_indent_3 { text-indent: 15px; } #mcuiujdfax .gt_indent_4 { text-indent: 20px; } #mcuiujdfax .gt_indent_5 { text-indent: 25px; } #mcuiujdfax .katex-display { display: inline-flex !important; margin-bottom: 0.75em !important; } #mcuiujdfax div.Reactable > div.rt-table > div.rt-thead > div.rt-tr.rt-tr-group-header > div.rt-th-group:after { height: 0px !important; } Family_History_CVD Total No Yes Sex     Men 112 34 146     Women 101 53 154 Total 213 87 300 10.9.5 Regression table with tbl_regression() If you want to create a regression table, you can fit a model and use tbl_regression() to summarize the results. Use gtsave() to save the results. model &lt;- lm(Cholesterol ~ Age + Sex + BMI, data = data) summary(model) ## ## Call: ## lm(formula = Cholesterol ~ Age + Sex + BMI, data = data) ## ## Residuals: ## Min 1Q Median 3Q Max ## -77.394 -20.480 -0.201 22.180 79.460 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 202.86854 12.74511 15.917 &lt;2e-16 *** ## Age 0.01257 0.10073 0.125 0.901 ## SexWomen -1.11486 3.52738 -0.316 0.752 ## BMI -0.09220 0.46110 -0.200 0.842 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 30.36 on 296 degrees of freedom ## Multiple R-squared: 0.0004917, Adjusted R-squared: -0.009638 ## F-statistic: 0.04854 on 3 and 296 DF, p-value: 0.9858 tbl_regression(model) %&gt;% as_gt() #jweprkgrac table { font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } #jweprkgrac thead, #jweprkgrac tbody, #jweprkgrac tfoot, #jweprkgrac tr, #jweprkgrac td, #jweprkgrac th { border-style: none; } #jweprkgrac p { margin: 0; padding: 0; } #jweprkgrac .gt_table { display: table; border-collapse: collapse; line-height: normal; margin-left: auto; margin-right: auto; color: #333333; font-size: 16px; font-weight: normal; font-style: normal; background-color: #FFFFFF; width: auto; border-top-style: solid; border-top-width: 2px; border-top-color: #A8A8A8; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #A8A8A8; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; } #jweprkgrac .gt_caption { padding-top: 4px; padding-bottom: 4px; } #jweprkgrac .gt_title { color: #333333; font-size: 125%; font-weight: initial; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; border-bottom-color: #FFFFFF; border-bottom-width: 0; } #jweprkgrac .gt_subtitle { color: #333333; font-size: 85%; font-weight: initial; padding-top: 3px; padding-bottom: 5px; padding-left: 5px; padding-right: 5px; border-top-color: #FFFFFF; border-top-width: 0; } #jweprkgrac .gt_heading { background-color: #FFFFFF; text-align: center; border-bottom-color: #FFFFFF; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #jweprkgrac .gt_bottom_border { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #jweprkgrac .gt_col_headings { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; } #jweprkgrac .gt_col_heading { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 6px; padding-left: 5px; padding-right: 5px; overflow-x: hidden; } #jweprkgrac .gt_column_spanner_outer { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: normal; text-transform: inherit; padding-top: 0; padding-bottom: 0; padding-left: 4px; padding-right: 4px; } #jweprkgrac .gt_column_spanner_outer:first-child { padding-left: 0; } #jweprkgrac .gt_column_spanner_outer:last-child { padding-right: 0; } #jweprkgrac .gt_column_spanner { border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: bottom; padding-top: 5px; padding-bottom: 5px; overflow-x: hidden; display: inline-block; width: 100%; } #jweprkgrac .gt_spanner_row { border-bottom-style: hidden; } #jweprkgrac .gt_group_heading { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; text-align: left; } #jweprkgrac .gt_empty_group_heading { padding: 0.5px; color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; vertical-align: middle; } #jweprkgrac .gt_from_md > :first-child { margin-top: 0; } #jweprkgrac .gt_from_md > :last-child { margin-bottom: 0; } #jweprkgrac .gt_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; margin: 10px; border-top-style: solid; border-top-width: 1px; border-top-color: #D3D3D3; border-left-style: none; border-left-width: 1px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 1px; border-right-color: #D3D3D3; vertical-align: middle; overflow-x: hidden; } #jweprkgrac .gt_stub { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; } #jweprkgrac .gt_stub_row_group { color: #333333; background-color: #FFFFFF; font-size: 100%; font-weight: initial; text-transform: inherit; border-right-style: solid; border-right-width: 2px; border-right-color: #D3D3D3; padding-left: 5px; padding-right: 5px; vertical-align: top; } #jweprkgrac .gt_row_group_first td { border-top-width: 2px; } #jweprkgrac .gt_row_group_first th { border-top-width: 2px; } #jweprkgrac .gt_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #jweprkgrac .gt_first_summary_row { border-top-style: solid; border-top-color: #D3D3D3; } #jweprkgrac .gt_first_summary_row.thick { border-top-width: 2px; } #jweprkgrac .gt_last_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #jweprkgrac .gt_grand_summary_row { color: #333333; background-color: #FFFFFF; text-transform: inherit; padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; } #jweprkgrac .gt_first_grand_summary_row { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-top-style: double; border-top-width: 6px; border-top-color: #D3D3D3; } #jweprkgrac .gt_last_grand_summary_row_top { padding-top: 8px; padding-bottom: 8px; padding-left: 5px; padding-right: 5px; border-bottom-style: double; border-bottom-width: 6px; border-bottom-color: #D3D3D3; } #jweprkgrac .gt_striped { background-color: rgba(128, 128, 128, 0.05); } #jweprkgrac .gt_table_body { border-top-style: solid; border-top-width: 2px; border-top-color: #D3D3D3; border-bottom-style: solid; border-bottom-width: 2px; border-bottom-color: #D3D3D3; } #jweprkgrac .gt_footnotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #jweprkgrac .gt_footnote { margin: 0px; font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #jweprkgrac .gt_sourcenotes { color: #333333; background-color: #FFFFFF; border-bottom-style: none; border-bottom-width: 2px; border-bottom-color: #D3D3D3; border-left-style: none; border-left-width: 2px; border-left-color: #D3D3D3; border-right-style: none; border-right-width: 2px; border-right-color: #D3D3D3; } #jweprkgrac .gt_sourcenote { font-size: 90%; padding-top: 4px; padding-bottom: 4px; padding-left: 5px; padding-right: 5px; } #jweprkgrac .gt_left { text-align: left; } #jweprkgrac .gt_center { text-align: center; } #jweprkgrac .gt_right { text-align: right; font-variant-numeric: tabular-nums; } #jweprkgrac .gt_font_normal { font-weight: normal; } #jweprkgrac .gt_font_bold { font-weight: bold; } #jweprkgrac .gt_font_italic { font-style: italic; } #jweprkgrac .gt_super { font-size: 65%; } #jweprkgrac .gt_footnote_marks { font-size: 75%; vertical-align: 0.4em; position: initial; } #jweprkgrac .gt_asterisk { font-size: 100%; vertical-align: 0; } #jweprkgrac .gt_indent_1 { text-indent: 5px; } #jweprkgrac .gt_indent_2 { text-indent: 10px; } #jweprkgrac .gt_indent_3 { text-indent: 15px; } #jweprkgrac .gt_indent_4 { text-indent: 20px; } #jweprkgrac .gt_indent_5 { text-indent: 25px; } #jweprkgrac .katex-display { display: inline-flex !important; margin-bottom: 0.75em !important; } #jweprkgrac div.Reactable > div.rt-table > div.rt-thead > div.rt-tr.rt-tr-group-header > div.rt-th-group:after { height: 0px !important; } Characteristic Beta 95% CI p-value Age 0.01 -0.19, 0.21 >0.9 Sex     Men — —     Women -1.1 -8.1, 5.8 0.8 BMI -0.09 -1.0, 0.82 0.8 Abbreviation: CI = Confidence Interval 10.10 Exercises We will work with the SNPSdataset.txt (find it in the weekly assignments submission section). Create a report using rmarkdown. Include in your report: the proportion of cases and controls. the proportion of women and men. the proportion of women and men within cases and controls, respectively. summary table with the information for cases and controls, age and gene_expression values stratifying by sex. summary table with the information for all SNPs genotypes when stratifying by sex summary table with the information for all SNPs genotypes when stratifying by sex and case/control Alternate the use of tables and plots (basic plots from session 2) to display the information. Work with the functions included in the dplyrand tidyr packages. The desired format to submit the report is an html. It is important to describe the results that you show to answer each question. Is not enough providing the code (Example: The dataset is mainly defined by XX % of women and % men. When we stratify by clinical status, we observe a higher percentage of women in controls than in cases). 10.10.1 Extra exercises You can also try to report the same results with rmarkdown in other formats (word, pdf). If you want, you can try to work with other options that we have seen in class (Sweave, Shiny, Beamer). It is not mandatory and it does not have to be submitted. Only the HTML file of the markdown. If you want to work with shiny, you can continue the following R code: ShinySNPSapp.R. Some indications are explained in the script in order to display the main information. "],["section-10.-advanced-data-visualization-ggplot2-package.html", "11 SECTION 10. Advanced Data Visualization: ggplot2 package 11.1 Why ggplot2? 11.2 Installation 11.3 Usage 11.4 Geometric Objects And Aesthetics 11.5 Examples 11.6 Exercises: Create new plots for genetic data visualization using the SNPdataset.txt dataset. Create a report in .html format and display and describe each one of the plots.", " 11 SECTION 10. Advanced Data Visualization: ggplot2 package ggplot2 is an R package for producing statistical, or data, graphics, but it is unlike most other graphics packages because it has a deep underlying code. This code is composed of a set of independent components that can be composed in many different ways. ggplot2 is designed to work in a layered fashion, starting with a layer showing the raw data then adding layers of annotation and statistical summaries. 11.1 Why ggplot2? Advantages of ggplot2 consistent underlying grammar of graphics plot specification at a high level of abstraction very flexible There are a lot of cheatsheets and sources that allow us to find examples and code to plot more advanced graphics with ggplot. We will start step by step. 11.2 Installation install.packages(&quot;ggplot2&quot;) library(ggplot2) (You’ll need to make sure you have the most recent version of R to get the most recent version of ggplot) 11.3 Usage It’s hard to describe how ggplot2 works because it embodies a deep philosophy of visualization. However, in most cases you start with ggplot(), supply a dataset and aesthetic mapping (with aes()). 11.4 Geometric Objects And Aesthetics 11.4.1 Aesthetic Mapping In ggplot land aesthetic means “something you can see”. Examples include: position (i.e., on the x and y axes) color (“outside” color) fill (“inside” color) shape (of points) linetype size Each type of geom accepts only a subset of all aesthetics-refer to the geom help pages to see what mappings each geom accepts. Aesthetic mappings are set with the aes() function. 11.4.2 Geometic Objects (geom) Geometric objects are the actual marks (different visual object to represent the data) we put on a plot. Examples include: points (geom_point, for scatter plots, dot plots, etc) lines (geom_line, for time series, trend lines, etc) boxplot (geom_boxplot, for, well, boxplots!) barplot (geom_bar, for barplots) A plot must have at least one geom; there is no upper limit. You can add a geom to a plot using the + operator. You can get a list of available geometric objects using the code below: help.search(&quot;geom_&quot;, package = &quot;ggplot2&quot;) The ggplot() function is used to initialize the basic graph structure, then we add to it. The basic idea is that you specify different parts of the plot, and add them together using the + operator. These parts are often referred to as layers. ggplot2 requires a data frame as input. Let’s start: 11.5 Examples Install and Load the ggplot2 package. Explore the diamonds dataset. The diamonds data frame contains information on the prices and various metrics of \\(~54,000\\) diamonds. library(ggplot2) names(diamonds) ## [1] &quot;carat&quot; &quot;cut&quot; &quot;color&quot; &quot;clarity&quot; &quot;depth&quot; &quot;table&quot; &quot;price&quot; ## [8] &quot;x&quot; &quot;y&quot; &quot;z&quot; dim(diamonds) ## [1] 53940 10 We can check the class of each one of the variables: head(diamonds) ## # A tibble: 6 × 10 ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 ## 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31 ## 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31 ## 4 0.29 Premium I VS2 62.4 58 334 4.2 4.23 2.63 ## 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75 ## 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48 str(diamonds) ## tibble [53,940 × 10] (S3: tbl_df/tbl/data.frame) ## $ carat : num [1:53940] 0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ... ## $ cut : Ord.factor w/ 5 levels &quot;Fair&quot;&lt;&quot;Good&quot;&lt;..: 5 4 2 4 2 3 3 3 1 3 ... ## $ color : Ord.factor w/ 7 levels &quot;D&quot;&lt;&quot;E&quot;&lt;&quot;F&quot;&lt;&quot;G&quot;&lt;..: 2 2 2 6 7 7 6 5 2 5 ... ## $ clarity: Ord.factor w/ 8 levels &quot;I1&quot;&lt;&quot;SI2&quot;&lt;&quot;SI1&quot;&lt;..: 2 3 5 4 2 6 7 3 4 5 ... ## $ depth : num [1:53940] 61.5 59.8 56.9 62.4 63.3 62.8 62.3 61.9 65.1 59.4 ... ## $ table : num [1:53940] 55 61 65 58 58 57 57 55 61 61 ... ## $ price : int [1:53940] 326 326 327 334 335 336 336 337 337 338 ... ## $ x : num [1:53940] 3.95 3.89 4.05 4.2 4.34 3.94 3.95 4.07 3.87 4 ... ## $ y : num [1:53940] 3.98 3.84 4.07 4.23 4.35 3.96 3.98 4.11 3.78 4.05 ... ## $ z : num [1:53940] 2.43 2.31 2.31 2.63 2.75 2.48 2.47 2.53 2.49 2.39 ... We will structure this “Examples” section by showing different types of graphics based on our main goal and the type of variables that we want to work with: If we want to analyze: Frequency (categorical variable): barplot (e.g. Cut from diamonds) Part of a whole (two categorical variables: proportion of observations of one variable’s categories among the categories of a second variable): stacked/grouped barplot (e.g. Cut-color from diamonds) Distribution (continuous variable): histogram, boxplot, density plot (e.g. depth, price, x…. from diamonds) Correlation (2 continuous variables): scatter plot There are more options that we would like to analyze/explore. In case you want to learn about other graphics/options, visit the following link: https://r-graph-gallery.com/ . You will find a wide range of options to graphically describe your data. 11.5.1 Categorical Variables 11.5.1.1 Barplot We have a categorical variable and we want to find the frequency of appearance for each level of the factor. The main idea is to plot the frequency that we observe for each category of the categorical variable (check class(Variable): it must be a factor). table(diamonds$cut) ## ## Fair Good Very Good Premium Ideal ## 1610 4906 12082 13791 21551 ggplot(diamonds, aes(x=cut)) + geom_bar() Using pipes we can proceed as follows: diamonds %&gt;% ggplot(aes(x=cut)) + geom_bar() Imagine that we want to fill each bar with a color according to each category of the variable cut ggplot(diamonds, aes(x=cut)) + geom_bar(aes(fill=cut)) ##same if we do: ggplot(diamonds, aes(x=cut,fill=cut)) + geom_bar() Now we want to display the result of the table of contingency relating cut*color. We want to see how many observations for each category of the variable cut do we have but stratifying by color. table(diamonds$cut, diamonds$color) ## ## D E F G H I J ## Fair 163 224 312 314 303 175 119 ## Good 662 933 909 871 702 522 307 ## Very Good 1513 2400 2164 2299 1824 1204 678 ## Premium 1603 2337 2331 2924 2360 1428 808 ## Ideal 2834 3903 3826 4884 3115 2093 896 ##stacked ggplot(diamonds, aes(x=cut, fill=color)) + geom_bar(position = &quot;stack&quot;) ##not stacked ggplot(diamonds, aes(x=cut, fill=color)) + geom_bar(position = &quot;dodge&quot;) If we want to display within group the relative proportion of each type of color? ggplot(diamonds, aes(x=cut, fill=color)) + geom_bar(position = &quot;fill&quot;) ##when adding + scale_y_continuous(labels = scales::percent_format()) we can see the y-axis as percent (x out of 100%). how to change the coordinates of the plot? Use coord_flip() ggplot(diamonds, aes(x=cut, fill=color)) + geom_bar(position = &quot;dodge&quot;) + coord_flip() 11.5.2 Quantitative Variables 11.5.2.1 Distribution 11.5.2.1.1 Histograms Let’s plot the distribution of the variable price. ggplot(data=diamonds) + geom_histogram(binwidth=500, aes(x=price)) + ##### binwidth=change width histogram ggtitle(&quot;Diamond Price Distribution&quot;) + xlab(&quot;Diamond Price U$ - Binwidth 500&quot;) + ylab(&quot;Frequency&quot;) + xlim(0,2500) ##let&#39;s see at different levels p1&lt;-ggplot(data=diamonds) + geom_histogram(binwidth=50, aes(x=price)) + ##### binwidth=change width histogram ggtitle(&quot;Diamond Price Distribution&quot;) + xlab(&quot;Diamond Price U$ - Binwidth 50&quot;) + ylab(&quot;Frequency&quot;) + xlim(0,2500) p2&lt;- ggplot(data=diamonds) + geom_histogram(binwidth=10, aes(x=price)) + ##### binwidth=change width histogram ggtitle(&quot;Diamond Price Distribution&quot;) + xlab(&quot;Diamond Price U$ - Binwidth 10&quot;) + ylab(&quot;Frequency&quot;) + xlim(0,2500) ##warning because our maximum value in the x-axis is lower than the maximum value of the variable price ##observations that are not plotted library(ggpubr) ggarrange(ncol=2, nrow=1, p1,p2) ## ggarrange allows us to plot together different plots: we can define number of columns (ncol) and number of rows(nrow) to divide the area where we want to add the plots How to customize our histogram? 1) Color and fill ggplot(data=diamonds, aes(x=price)) + geom_histogram(binwidth=10, color=&quot;steelblue&quot;, fill=&quot;orange&quot;) + ggtitle(&quot;Diamond Price Distribution&quot;) + xlab(&quot;Diamond Price U$ - Binwidth 10&quot;) + ylab(&quot;Frequency&quot;) + xlim(0,2500) 2) Add mean line We well use the argument geom_vlinewhere we can indicate that we want a vertical line (vline) where price takes the mean value. We will indicate it in the xintercept. The arguments linetype and lwd allow us to change the style (linetype) and width (lwd) of the line. ggplot(data=diamonds, aes(x=price)) + geom_histogram(binwidth=10, color=&quot;black&quot;, fill=&quot;steelblue&quot;) + ggtitle(&quot;Diamond Price Distribution&quot;) + xlab(&quot;Diamond Price U$ - Binwidth 10&quot;) + ylab(&quot;Frequency&quot;) + # xlim(0,2500) + geom_vline(aes(xintercept=mean(price)), color=&quot;red&quot;,linetype=&quot;dashed&quot;,lwd=2) We can also use geom_hline with the argument yintercept to define an horizontal line. Imagine that we want to define an horizontal line when the frequency is above 200. ggplot(data=diamonds, aes(x=price)) + geom_histogram(binwidth=10, color=&quot;black&quot;, fill=&quot;steelblue&quot;) + ggtitle(&quot;Diamond Price Distribution&quot;) + xlab(&quot;Diamond Price U$ - Binwidth 10&quot;) + ylab(&quot;Frequency&quot;) + # xlim(0,2500) + geom_hline(aes(yintercept=200), color=&quot;red&quot;,linetype=&quot;dashed&quot;,lwd=1) 3) Overlap two or more histograms: imagine that we want to plot the distribution of the variable price according to different categories. For example, based on the variable cut (has 5 categories). We will compare the distribution of the variable price among three of these categories: “Ideal”, “Good” or “Fair”. unique(diamonds$cut) ## [1] Ideal Premium Good Very Good Fair ## Levels: Fair &lt; Good &lt; Very Good &lt; Premium &lt; Ideal table(diamonds$cut) ## ## Fair Good Very Good Premium Ideal ## 1610 4906 12082 13791 21551 ggplot(diamonds, aes(x=price)) + geom_histogram(data=subset(diamonds, diamonds$cut==&quot;Ideal&quot;), binwidth=10, color=&quot;black&quot;, fill=&quot;orange&quot;) + geom_histogram(data=subset(diamonds, diamonds$cut==&quot;Good&quot;), binwidth=10, color=&quot;black&quot;, fill=&quot;darkgreen&quot;) + geom_histogram(data=subset(diamonds, diamonds$cut==&quot;Fair&quot;), binwidth=10, color=&quot;black&quot;, fill=&quot;red&quot;) + ggtitle(&quot;Diamond Price Distribution by Cut&quot;) + xlab(&quot;Diamond Price U$ - Binwidth 10&quot;) + ylab(&quot;Frequency&quot;) + xlim(0,2500) If we want to display the overlap among all categories for the variable cut: ggplot(diamonds, aes(x=price)) + geom_histogram(binwidth=10, aes(fill=cut), colour=&quot;black&quot;) + ggtitle(&quot;Diamond Price Distribution by Cut&quot;) + xlab(&quot;Diamond Price U$ - Binwidth 10&quot;) + ylab(&quot;Frequency&quot;) + xlim(0,2500) 11.5.2.1.2 Density plots We display the density plot only for the cases where price is below 1000. diamonds %&gt;% filter( price&lt;1000 ) %&gt;% ggplot( aes(x=price)) + geom_density(fill=&quot;#69b3a2&quot;, color=&quot;#e9ecef&quot;, alpha=0.8) Now for all the cases: diamonds %&gt;% ggplot( aes(x=price)) + geom_density(fill=&quot;#69b3a2&quot;, color=&quot;#e9ecef&quot;, alpha=0.8) And stratifying by cut: diamonds %&gt;% ggplot( aes(x=price, fill=cut, color=cut)) + geom_density(alpha=0.8) ##color=&quot;gray&quot; 11.5.2.1.3 Boxplots When we want to observe the distribution of a continuous variable, we can use box plots in order to visualize the median of the distribution, the first and third quantile, the variability across all the observations and outliers. We can plot these distributions stratifying by categorical variables, to compare between different categories of the same factor. In the previous section, we have seen the distribution of the variable price in a histogram that shows the range of prices that are more frequent in our sample. We have also plotted the observations according to specific levels of the factor cut. Now, we are not interested in the frequency but in the distribution of the variable price. 1) We want to plot the distribution of the price for all the observations, without distinguishing by any condition: ggplot(diamonds, aes(x=factor(0),y=price)) + geom_boxplot() + ggtitle(&quot;Diamond Price&quot;) + ylab(&quot;Diamond Price U$&quot;) + coord_cartesian(ylim=c(0,7500)) + theme(axis.title.x=element_blank(),## removes title in the x-axis axis.text.x=element_blank(), ###removes text ===&gt; 0 in the x-axis axis.ticks.x=element_blank()) ## removes the tick (line) 2) We want to plot the distribution of the variable price for each one of the categories of the variable cut. We will fill each box according to the each level (cut). ggplot(diamonds, aes(x=cut,y=price, fill=cut)) + geom_boxplot() + ggtitle(&quot;Diamond Price&quot;) + ylab(&quot;Diamond Price U$&quot;) + coord_cartesian(ylim=c(0,7500)) 3) If we want to remove the legend ggplot(diamonds, aes(x=cut,y=price, fill=cut)) + geom_boxplot() + ggtitle(&quot;Diamond Price&quot;) + ylab(&quot;Diamond Price U$&quot;) + coord_cartesian(ylim=c(0,7500)) + theme(legend.position = &quot;none&quot;) 4) If we want lighter colors ggplot(diamonds, aes(x=cut,y=price, fill=cut)) + geom_boxplot(alpha=0.3) + ggtitle(&quot;Diamond Price&quot;) + ylab(&quot;Diamond Price U$&quot;) + coord_cartesian(ylim=c(0,7500)) 5) If we want to observe each one of the points (observations) ggplot(diamonds, aes(x=cut,y=price, fill=cut)) + geom_boxplot(alpha=0.6) + geom_jitter(color=&quot;black&quot;, alpha=0.3, position=position_jitter(), size=0.6) + ### add points for each observation &gt;&gt; it allows us to find clusters of individuals ggtitle(&quot;Diamond Price&quot;) + ylab(&quot;Diamond Price U$&quot;) + coord_cartesian(ylim=c(0,7500)) 11.5.2.1.4 Violin plot diamonds %&gt;% ggplot( aes(x=cut,y=price, fill=cut)) + geom_violin(width=1.4) + geom_boxplot(width=0.1, color=&quot;gray&quot;, alpha=0.1) + theme_classic2() + theme( legend.position=&quot;none&quot;, plot.title = element_text(size=11) ) + ggtitle(&quot;A Violin wrapping a boxplot&quot;) 11.5.2.2 Correlation between 2 variables 11.5.2.2.1 Scatterplot Now, we are interested in plotting together the observations of two continuous variables. For example, we want to assess the relationship between the variable depth and price: p&lt;-ggplot(diamonds, aes(x = depth, y = price)) + geom_point() p Let’s see the distribution of each variable: p2&lt;- ggMarginal(p,type=&quot;histogram&quot;) p2 We can also assess the association between variables x and y: ggplot(diamonds, aes(x = x, y = y)) + geom_point() Let’s graphically analayze the association between the price of a diamond and its weight (carat). In addition, we will color the points based on the quality of the cut. ggplot(diamonds, aes(x = carat, y = price, color=cut)) + geom_point() In this last situation we can be interested in performing a linear regression model to assess whether the weight of the diamond (carat) predicts its price. We can also plot the regression line and equation. We will color the observations based on the weight (explanatory variable) of each diamond. diamonds$pred.SC &lt;- predict(lm(price ~ carat, data = diamonds)) ##same if we save the output of the model in a new object &quot;r&quot; =&gt; r&lt;- lm(price ~ carat, data = diamonds) and then we select the fitted values =&gt; r$fitted.values p1 &lt;- ggplot(diamonds, aes(x = carat, y = price)) ###ggplot2 p1 + geom_point(aes(color = carat)) + geom_line(aes(y = pred.SC)) 11.5.2.2.2 Smoothers Not all geometric objects are simple shapes-the smooth geom includes a line and a ribbon. We can define different methods, but by default it applies generalized additive models, for non-linear associations. It assumes that the outcome can be modelled by a sum of arbitrary functions of each feature. We can also assume linear association and define it in the argument metod. Let’s see the same example that we have seen in the previous section by using geom_smooth and adding the equation of the regression line. library(ggpmisc) ## geom_smooth and lm formula&lt;- y~x p1+ geom_point(aes(color = carat)) + geom_smooth(method = &quot;lm&quot;, color=&quot;red&quot;,se = TRUE) + ##method=&quot;lm&quot; ## se=F =&gt; do not show confidence bands stat_poly_eq(aes(label = paste(..eq.label.., ..rr.label.., sep = &quot;~~~&quot;)), formula = formula, size = 7) Let’s check the output of the model: model&lt;-lm(price ~ carat, data = diamonds) summary(model) ## ## Call: ## lm(formula = price ~ carat, data = diamonds) ## ## Residuals: ## Min 1Q Median 3Q Max ## -18585.3 -804.8 -18.9 537.4 12731.7 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -2256.36 13.06 -172.8 &lt;2e-16 *** ## carat 7756.43 14.07 551.4 &lt;2e-16 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 1549 on 53938 degrees of freedom ## Multiple R-squared: 0.8493, Adjusted R-squared: 0.8493 ## F-statistic: 3.041e+05 on 1 and 53938 DF, p-value: &lt; 2.2e-16 Let’s see how does it work when geom_smooth do not assume a linear relationship. p1 + geom_point(aes(color = carat)) + geom_smooth(color=&quot;red&quot;) ##adds a trend line over an existing plot. It also adds confidence bands on the smooth. By default, the method=&quot;gam&quot; 11.5.3 More advanced code: customizing your plots 11.5.3.1 Adding text Let’s remember that we can summarize the counts of a categorical variable by using geom_bar(). ggplot(diamonds, aes(x=cut, fill=cut)) + geom_bar() And that we can also assess for each category of a categorical variable, the proportion of cases that we observe for each one of the categories of a second categorical variable (remember contingency table). plot&lt;- ggplot(diamonds, aes(x=cut, fill=color)) + geom_bar() plot 1) Geom_text: We want to add text that can help us to obtain more information about the counts. ## Counts plot+ geom_text(stat=&quot;count&quot;, aes(label=..count..), position = position_stack(vjust = 0.5), ###vjust = center of the box size=2.5, color=&quot;white&quot;) Let’s add the percentage of observations instead of the frequency. We need to work with the data. First option: creating data.frame from a prop.table round(prop.table(table(diamonds$cut, diamonds$color),1)*100,2) ## ## D E F G H I J ## Fair 10.12 13.91 19.38 19.50 18.82 10.87 7.39 ## Good 13.49 19.02 18.53 17.75 14.31 10.64 6.26 ## Very Good 12.52 19.86 17.91 19.03 15.10 9.97 5.61 ## Premium 11.62 16.95 16.90 21.20 17.11 10.35 5.86 ## Ideal 13.15 18.11 17.75 22.66 14.45 9.71 4.16 diamonds_perc&lt;- data.frame(round(prop.table(table(diamonds$cut, diamonds$color),1)*100,2)) ##we could have made it differently, but is the most direct way head(diamonds_perc) ##Var1 =&gt; variable cut, Var 2 =&gt; variable color, Freq is actually percentage ## Var1 Var2 Freq ## 1 Fair D 10.12 ## 2 Good D 13.49 ## 3 Very Good D 12.52 ## 4 Premium D 11.62 ## 5 Ideal D 13.15 ## 6 Fair E 13.91 colnames(diamonds_perc)&lt;-c(&quot;cut&quot;,&quot;color&quot;,&quot;Percentage&quot;) ggplot(diamonds_perc, aes(x=cut, y=Percentage, fill=color)) + geom_bar(position=&quot;stack&quot;,stat=&quot;identity&quot;) + geom_text(aes(x=cut, y=Percentage, label=Percentage), ##paste0(Percentage,&quot;%) if we want the format XX% position = position_stack(vjust = 0.5), ###vjust = center of the box size=2.5, color=&quot;white&quot;) Second option: working with pipes diamonds_perc2&lt;- diamonds %&gt;% group_by(cut, color) %&gt;% summarise( n=n()) %&gt;% mutate(prop=n/sum(n)) diamonds_perc2 %&gt;% group_by(cut) %&gt;% summarise(total = sum(prop)) ## # A tibble: 5 × 2 ## cut total ## &lt;ord&gt; &lt;dbl&gt; ## 1 Fair 1 ## 2 Good 1 ## 3 Very Good 1 ## 4 Premium 1 ## 5 Ideal 1 diamonds_perc2 %&gt;% ggplot(aes(x=cut, y=prop, fill=color)) + geom_bar(position=&quot;stack&quot;,stat=&quot;identity&quot;) + geom_text(aes(x=cut, y=prop, label=prop), position = position_stack(vjust = 0.5), ###vjust = center of the box size=2.5, color=&quot;white&quot;) Options to display the text: diamonds_perc2 %&gt;% ggplot(aes(x=cut, y=prop, fill=color)) + geom_bar(position=&quot;stack&quot;,stat=&quot;identity&quot;) + geom_text(aes(x=cut, y=prop, label=paste0(round(prop*100,2),&quot;%&quot;)), position = position_stack(vjust = 0.5), ###vjust = center of the box size=2.5, color=&quot;white&quot;) + scale_y_continuous(labels = scales::percent_format()) ##if we want the format XX% 11.5.3.2 Changing style theme_minimal theme_light theme_classic theme_bw: very similar to theme_light plot_example&lt;- ggplot(diamonds, aes(x=cut,y=price, fill=cut)) + geom_boxplot() + ggtitle(&quot;Diamond Price&quot;) + ylab(&quot;Diamond Price U$&quot;) + coord_cartesian(ylim=c(0,7500)) + theme(legend.position = &quot;none&quot;, axis.text.x = element_text(angle=90)) ##rotate p1&lt;- plot_example + theme_minimal() p2&lt;- plot_example + theme_light() p3&lt;- plot_example + theme_classic() ggarrange(ncol=2,nrow=2, p1,p2,p3,plot_example) 11.5.3.3 Facet_grid and facet_wrap: stratifying by categories 1) Facet_wrap We will follow the previous example. Remember that we want to plot the distribution of the variable price (y-axis) for each category of the variable cut. Imagine that for a specific category of the variable cut, the distribution of the variable price does not show a high variability. The graphic will display all the categories together and for a concrete one, the box won’t almost appear. Let’s modify the values of a concrete category just to observe it: diamonds3&lt;- diamonds diamonds3$price[diamonds$cut==&quot;Ideal&quot;]&lt;- sample(150:1050,nrow(diamonds[diamonds$cut==&quot;Ideal&quot;, ]),replace=TRUE) ggplot(diamonds3, aes(x=cut,y=price, fill=cut)) + geom_boxplot() + ggtitle(&quot;Diamond Price&quot;) + ylab(&quot;Diamond Price U$&quot;) + coord_cartesian(ylim=c(0,7500)) + theme(legend.position = &quot;none&quot;) If we want to zoom in each specific category of the variable cut: ggplot(diamonds3, aes(x=cut,y=price, fill=cut)) + geom_boxplot() + ggtitle(&quot;Diamond Price&quot;) + ylab(&quot;Diamond Price U$&quot;) + theme(legend.position = &quot;none&quot;) + facet_wrap(cut~., scales=&quot;free&quot;) Remember the different styles, we will customize specific aspects: ggplot(diamonds3, aes(x=cut,y=price, fill=cut)) + geom_boxplot() + ggtitle(&quot;Diamond Price&quot;) + ylab(&quot;Diamond Price U$&quot;) + coord_cartesian(ylim=c(0,7500)) + theme(legend.position = &quot;none&quot;) + facet_wrap(cut~., scales=&quot;free&quot;) + theme_light() + ##let&#39;s add more things theme(strip.text = element_text(face=&quot;bold&quot;, size=9, colour = &quot;black&quot;)) + ## we want the titles of each box in bold theme(strip.background = element_rect(fill=&quot;lightgray&quot;, colour=&quot;black&quot;,size=1)) ## we want to change the appearance of the box 2) Facet_grid Now, imagine that we are not only interested in the distribution of the variable price for each category of cut but also we want to display it according to the variable color. It means that we are interested in the distribution of price per each new variable resulting from the intersection color x cut. We can cross them and visually inspect it by using facet_grid: ggplot(diamonds3, aes(x=cut,y=price, fill=cut)) + geom_boxplot() + ggtitle(&quot;Diamond Price&quot;) + ylab(&quot;Diamond Price U$&quot;) + coord_cartesian(ylim=c(0,7500)) + theme(legend.position = &quot;none&quot;) + facet_grid(color~cut, scales=&quot;free&quot;) + ##### cut will go to columns, and color to rows theme_light() Now we will work with the subset of the observations that show “I1” or “SI2” levels for the variable clarity. We want to plot the same graphic that before, but now displaying the distribution per each subgroup cut x color stratifying by clarity, that will just take two possible values. ggplot(diamonds3[diamonds3$clarity==&quot;I1&quot; |diamonds3$clarity==&quot;SI2&quot;, ], aes(x=cut,y=price, fill=clarity)) + geom_boxplot() + ggtitle(&quot;Diamond Price&quot;) + ylab(&quot;Diamond Price U$&quot;) + coord_cartesian(ylim=c(0,7500)) + theme(legend.position = &quot;none&quot;) + facet_grid(color~cut, scales=&quot;free&quot;) + theme_light() 11.5.4 Saving plots There are two ways in which figures and plots can be output to a file (rather than simply displaying on screen). The first (and easiest) is to export directly from the RStudio ‘Plots’ panel, by clicking on Export when the image is plotted. This will give you the option of png or pdf and selecting the directory to which you wish to save it to. It will also give you options to modify the size and resolution of the output image. The second option is to use R functions. This would allow you to run an R script from start to finish and automate the process (not requiring human point-and-click actions to save). In R’s terminology, output is directed to a particular output device and that dictates the output format that will be produced. A device must be created or “opened” in order to receive graphical output and, for devices that create a file on disk, the device must also be closed in order to complete the output. Let’s print our scatterplot to a pdf file format: png fast option: ggsave(\"my_plot.png\", plot = my_plot, width = 6, height = 4, dpi = 300) slow, but more customized option: png(&quot;myPath/To/The/Directory/NamePlot.png&quot;, res=600, width=10000, height=4500, pointsize=10, type=&quot;windows&quot;) ##res = rsolution (pixels per inch) ##pointsize = size of the text in points (text elements in the plot, font size) ##type = device to be used (windows-specific graphics device to create the png file) ggplot(diamonds3[diamonds3$clarity==&quot;I1&quot; |diamonds3$clarity==&quot;SI2&quot;, ], aes(x=cut,y=price, fill=clarity)) + geom_boxplot() + ggtitle(&quot;Diamond Price&quot;) + ylab(&quot;Diamond Price U$&quot;) + coord_cartesian(ylim=c(0,7500)) + theme(legend.position = &quot;none&quot;) + facet_grid(color~cut, scales=&quot;free&quot;) + theme_light() dev.off() pdf: replacing in the previous code the “.png” format by “.pdf”. 11.6 Exercises: Create new plots for genetic data visualization using the SNPdataset.txt dataset. Create a report in .html format and display and describe each one of the plots. 1. Analyze the distribution of the variable GENE_EXPRESSION. Create both a histogram and a boxplot to analyze the distribution of the variable GENE_EXPRESSION. Display them together (hint: use ggarrange). Create a histogram and a boxplot to analyze the distribution of the variable GENE_EXPRESSION for women and men separately. Use a single histogram to compare the distributions between sexes by overlapping both histograms and coloring the distribution for women in green and for men in blue. For the boxplot, also use green for women and blue for men (hint: use the argument scale_fill_manual). 2. Analyze the proportion of: Women and men displaying each genotype related to SNP1. Set the scale as a percentage (100%). Individuals with different genotypes for SNP5, grouped by cases and controls. Set the scale so all proportions sum up to 1. Women and men within cases and controls, filtering for individuals older than 35. 3. Use facet_wrap to show the frequency of each SNP1 genotype for women and men. Color the bars based on genotype (hint: use geom_bar to display frequency). 4. Use facet_grid to show the frequency of each genotype across all SNPs, comparing women and men. Arrange the grid so that SNPs are shown vertically and sex is shown horizontally. Color the bars based on genotype. Note that you’ll need to create a new variable called SNPS that includes all the different SNP categories (e.g., SNP1, SNP2, SNP5) and a new variable called genotype that contains each individual’s genotype for a specific SNP. Use the following code to transform the data: snps_long&lt;- snps %&gt;% pivot_longer( cols=2:6, names_to=&quot;SNP&quot;, values_to=&quot;Genotype&quot; ) You will work with the data.frame snps_long to create the plot. "],["section-11.-advanced-data-visualization-extra-part.html", "12 SECTION 11. Advanced Data Visualization: Extra Part 12.1 Useful plots for Omics Data Analysis 12.2 Other resources in R", " 12 SECTION 11. Advanced Data Visualization: Extra Part Beyond ggplot2, other related packages in R provide interesting resources to create advanced and informative visualizations. In this report you will find a summary of these additional tools. The content will be divided in two main sections: Useful plots for Omics Data Analysis and Other resources in R. 12.1 Useful plots for Omics Data Analysis 12.1.1 Heatmap We can extract only the genes that are identified as significant in a sample of 100 individuals and plot the expression of those genes using a heatmap. We create the data. library(reshape) dat &lt;- matrix(rnorm(1000), nrow = 100, ncol=100) rownames(dat)&lt;-paste(&quot;g&quot;,seq(1,100,1),sep=&quot;&quot;) colnames(dat)&lt;-paste(&quot;ID&quot;,seq(1,100,1),sep=&quot;.&quot;) dat.m &lt;- melt(dat) ##melt from reshape2 does the same as pivot_longer of tidyr (from wide to long format) head(dat.m) ## X1 X2 value ## 1 g1 ID.1 -0.4156362 ## 2 g2 ID.1 -0.8761643 ## 3 g3 ID.1 -0.3001513 ## 4 g4 ID.1 0.7376490 ## 5 g5 ID.1 1.9338655 ## 6 g6 ID.1 0.2370658 We plot the heatmap: ggplot(dat.m) + geom_tile(aes(x=X1, y=X2, fill=value)) + scale_fill_gradient2(low=&quot;blue&quot;, mid=&quot;white&quot;, high=&quot;red&quot;) + theme(axis.text.x = element_text(angle=90)) 12.1.2 Venn Diagram library(ggVennDiagram) x &lt;- list(A=letters[1:5],B=letters[1:10],C=letters[8:18]) x ## $A ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; ## ## $B ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; ## ## $C ## [1] &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; ggVennDiagram(x) library(UpSetR) x &lt;- list(A=letters[1:5],B=letters[1:10],C=letters[8:18]) x ## $A ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; ## ## $B ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; ## ## $C ## [1] &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; upset(fromList(x), order.by = &quot;freq&quot;) 12.1.2.1 Additional genome graphics ggbio Gviz RCircos Genome Graphs genoPlotR 12.2 Other resources in R 12.2.1 Advanced visualizations with ggpubr ggpubris an extension of ggplot2designed to simplify the process of creating publication-ready plots. While ggplot2 is highly flexible and powerful, it requires a bit of coding expertise to get polished, customized plots. ggpubr builds on ggplot2’s capabilities by providing functions that make it easier to create well-formatted statistical graphics with less effort. 12.2.1.1 Boxplot If we want to do multiple pairwise test against a reference group to compare the mean value of this group of reference with the rest of groups. ggboxplot(diamonds, x = &quot;clarity&quot;, y = &quot;price&quot;, color = &quot;clarity&quot;)+ theme(legend.position = &quot;none&quot;) + stat_compare_means(method = &quot;anova&quot;, label.y = max(diamonds$price)+10)+ # Add global p-value stat_compare_means(aes(label = after_stat(p.signif)), method = &quot;t.test&quot;, ref.group = &quot;SI1&quot;) All pairwise comparisons. We will reduce the number of comparisons to 3, by grouping different categories of the variable clarity in a new variable called ‘clarity_grouped’. diamonds&lt;- diamonds %&gt;% mutate(clarity_grouped=ifelse(clarity==&quot;SI2&quot;| clarity==&quot;SI1&quot; , &quot;S_class&quot;, ifelse(clarity==&quot;I1&quot;|clarity==&quot;IF&quot;,&quot;F_class&quot;,&quot;V_class&quot;))) stat.test&lt;- diamonds %&gt;% wilcox_test(price ~ clarity_grouped) %&gt;% adjust_pvalue(method = &quot;fdr&quot;) %&gt;% ##FDR add_significance(&quot;p.adj&quot;) %&gt;% add_xy_position(x = &quot;clarity_grouped&quot;, dodge = 0.8) stat.test$p.adj&lt;- round(stat.test$p.adj,8) ggboxplot(diamonds, x = &quot;clarity_grouped&quot;, y = &quot;price&quot;, color = &quot;clarity_grouped&quot;)+ theme_classic() + theme(strip.text.y = element_text(angle = 0,face=&quot;bold&quot;), strip.text.x = element_text(face=&quot;bold&quot;), legend.position = &quot;none&quot;)+ stat_pvalue_manual(stat.test, size = 3, label =&quot;{p.adj}{p.adj.signif}&quot;, tip.length = 0.02, step.increase = 0.05) 12.2.2 Dynamic plots with gganimate Sharing dynamic plots can be interesting to display the evolution of our variable of interest over time. You can check more information about gganimate. library(gganimate) ggplot(data = diamonds, mapping = aes(x = reorder(cut, price,FUN = mean),y = price)) + geom_boxplot(alpha=0.3, outlier.colour = &quot;blue&quot;) + geom_point(stat= &quot;summary&quot;, fun=mean, shape=16, size=1.5, color=&quot;red&quot;) + labs(x=&quot;Weight diamond (cut)&quot;, y=&quot;Price diamond&quot;) + theme (plot.title = element_text(size=10,vjust=2,hjust=0.5,face=&quot;bold&quot;)) + theme(axis.title.x = element_text(size=9)) + theme(axis.title.y = element_text(size=9)) + theme(axis.text.x = element_text(angle = 60, hjust = 1, size=9)) + transition_states( clarity, #### This is the variable based on which the transition between states will occur transition_length = 1, ##It represents the number of animation frames over which the transition should occur. state_length = 1 ## this parameter sets the number of frames each state should last before transitioning to the next state ) + enter_fade() + exit_shrink() + ease_aes(&#39;sine-in-out&#39;) + labs(title = &quot;Clarity: {closest_state}&quot;) ## NULL When creating reports you can not only share dynamic graphics but also interactive ones, which means that you allow the user to display the plots based on their preferences (filtering by specific variables, subsetting the data, and others). Check the crosstalk package and see the different options you have. 12.2.3 Interactive interfaces for creating plots 12.2.3.1 Esquisse This package is a ‘shiny’ gadget that allows to create ggplot2 figures interactively. You can visit the main page for further details in the following link We only need to run the command lin esquisser() in a new R chunk. 12.2.3.2 Ggplotgui Ggplotgui refers to a specific GUI (Graphical User Interface) for creating ggplot2-based visualizations. I is a graphical user interface (GUI) tool designed to facilitate the creation of ggplot2-based visualizations in R. It provides an interactive and user-friendly environment for users who might be less familiar with coding but want to leverage the powerful ggplot2 package for data visualization. Let’s check it: 1- install the package: install.packages::ggplotgui 2- run the following code in a chunk: ggplotgui::ggplot_shiny() "],["section-12.-introduction-to-shiny.html", "13 SECTION 12. Introduction to Shiny 13.1 Writing a Shiny Application in R 13.2 Elements for a Shiny App 13.3 Working with ShinyDashboard 13.4 Deploying the Application to Shinyapps.io 13.5 Take home 13.6 Final Task", " 13 SECTION 12. Introduction to Shiny In this lesson, we will work on the creation of a Shiny application to visualize specific data. The app will include interactive charts and styled data table. By following these detailed steps, we will set up and deploy a Shiny app on Shinyapps.io. Shiny and other related packages can be installed from CRAN. Let’s see the main functionalitites of the shiny-related packages: shiny provides the core functionality for building interactive web apps. shinydashboard offers tools for creating dashboards with Shiny. plotly converts ggplot2 graphics to interactive plots. DT renders interactive data tables. 13.1 Writing a Shiny Application in R Shiny applications have two components, a user interface object and a server function. Both components are passed as argument to the shinyApp function that created the app as a result of this UI/Server pair. 13.1.1 UI Layout The user interface (UI) defines how users interact with the application. We define the structure of the app to include tables and graphics and drop-down menus for selecting different parameters. This allows users to dynamically interact with the data. 13.1.2 Server Logic The server function processes user inputs and updates outputs. 13.1.3 Examples All the examples are extracted from https://shiny.posit.co/r/articles/start/basics/. Application Shiny 1: we plot a random distribution as a histogram with a requested number of bins. In the UI component we define the aspect/aesthetics of the application. In the server section, we define the steps needed to display the graphic we aim to plot. We use different elements to define both parts that will be discussed below. Try to execute all these lines and check the output after running the last line shinyApp(ui, server). Application Shiny 2: 13.2 Elements for a Shiny App 13.2.1 UI Components Check list of inputs: https://shiny.posit.co/r/components/ Check list of outpus (section Outputs): https://shiny.posit.co/r/components/ Function Type Description Example Use Case textInput Text Box A single-line input field where users can enter text. Collecting a user’s name or entering a search term. sliderInput Slider Allows the user to select a numeric value or range by sliding a handle. Setting a range for filtering data (e.g., selecting years or numeric thresholds). selectInput Dropdown Menu Provides a dropdown menu for choosing one or multiple options. Selecting a category from a list of items (e.g., region, product, or variable). checkboxInput Checkbox A simple checkbox for toggling between TRUE (checked) and FALSE (unchecked). Turning features on/off in a plot (e.g., showing gridlines or enabling normalization). radioButtons Radio Buttons A group of mutually exclusive choices displayed as a list of buttons. Selecting a chart type (e.g., bar chart, scatter plot, or line graph). fileInput File Upload Allows the user to upload a file to the server. Uploading a CSV file for analysis. numericInput Numeric Input Input box for entering a numeric value. Setting the sample size for simulation. dateInput Date Picker Provides a calendar for selecting a single date. Selecting a start or end date for time-series data. Function Type Description Example Use Case textOutput Text Displays reactive text or plain text generated in the server. Showing user selections or calculated results. plotOutput Plot Displays plots (e.g., ggplot2 or base R) created in the server. Visualizing distributions, time series, or trends in data. tableOutput Table Displays a static data table generated by R. Showing a summary table of aggregated data. DT::dataTableOutput Interactive Table Displays an interactive data table with sorting, filtering, and pagination (requires the DT package). Allowing users to explore a dataset interactively. imageOutput Image Displays static or dynamically generated images. Displaying uploaded or generated images (e.g., maps or diagrams). uiOutput Dynamic UI Dynamically renders UI components in the server. Generating custom input fields based on user choices. verbatimTextOutput Verbatim Text Displays unformatted text, often used for showing code or debugging output. Printing console output for diagnostics or displaying R expressions. 13.2.2 Server function Function Description Example Use Case input$&lt;inputId&gt; Accesses the value of an input element specified by its inputId. Retrieve the value of a slider (input$slider1) or a dropdown menu (input$dropdown1). observe Observes changes to inputs without returning a value (used for side effects). Updating a log file or triggering animations when a button is clicked. reactive Creates a reactive expression that can depend on inputs or other reactives. Defining a filtered dataset based on user selections. observeEvent Observes a specific event (like a button click) and runs code in response. Executing code only when a submit button is pressed. isolate Accesses inputs without triggering reactivity. Reading values of inputs without causing dependencies (e.g., snapshotting user input). Function Output Type Description Example Use Case renderText Text Generates text output for textOutput in the UI. Showing calculated values or messages. renderPlot Plot Generates a plot for plotOutput in the UI. Visualizing distributions, trends, or comparisons. renderTable Static Table Creates a table for tableOutput in the UI. Displaying a data summary or descriptive statistics. DT::renderDataTable Interactive Table Renders a table for DT::dataTableOutput in the UI (requires the DT package). Enabling sorting, searching, and pagination of large datasets. renderImage Image Renders an image for imageOutput in the UI. Displaying dynamically generated images (e.g., visual results of an algorithm). renderUI Dynamic UI Dynamically creates UI components for uiOutput in the UI. Generating UI elements (e.g., a new slider) based on user input or external data. renderPrint Verbatim Output Displays text or objects as they appear in the R console. Printing debugging information or showing raw data. 13.3 Working with ShinyDashboard Here we will describe an example and go step by step to understand the code behind the application. We will work with the dataset data_tidy.txt that we have used in previous classes. 1- We read the dataset and inspect the elements: We need to define what is our aim creating this application. Let’s define 3 main goals: To show a main page with the information reported in the App. Display “X” lines of observations (interactive). To show a descriptive table only for specific cases of the dataset (interactive filter). To display a graphic displaying the weight of the participants based on a specific factor (interactive input). 2- We define the UI and server function of the application: UI section To start a dashboard page we need to define at first dashboardPage in the first line of code and then write all the content inside the page. We will have a main header for the Shiny App that will be defined using the dashboardHeader function. Then, to describe a sidebar with the main sections of the App, we need to work with the dashboardSidebarfunction. Inside this section we can customize our sidebarMenu by adding as many items as we want to the application (menuItem). Once we have defined the main tabs that the app will have, we can start defining the content within each one of these tabs by indicating everything within the section dashboardBody. The content will be splitted by tabItem sections within a general tabItems label. Each tabItem relates to the differnent menuItems that appear in the sidebar. All the interactive inputs and outputs are defined in this part of the code. The body of the tabItemcan be divided into different spatial areas. The body can be treated as a region divided into 12 columns of equal width, and any number of rows, of variable height. When you place a box (or other item) in the grid, you can specify how many of the 12 columns you want it to occupy. Scheme: dashboardHeader dashboardSidebar &gt; sidebarMenu &gt; menuItem dashboardBody &gt; tabItems &gt; tabItem &gt; fluidRow &gt; box The aesthetics of a box can be modified, such as the color (status): “primary” (blue) “info” (light blue) “success” (green) “warning” (orange) “danger” (red)`. Server function: 3- We run the application Summary: 13.4 Deploying the Application to Shinyapps.io Create a Shinyapps.io Account: https://www.shinyapps.io/?ref=lorcanmason.com a- First, sign up: b- Second, add a token: Configure deployment: 2.1 Configure your account: in Rstudio, load the rsconnect package and set your account information a- install.packages(\"rsconnect\") b- library(rsconnect) c- rsconnect::setAccountInfo(name='YOUR_ACCOUNT_NAME', token='YOUR_TOKEN', secret='YOUR_SECRET'): replace it with your Shinyapps.io credentials: Go to your shinyapps.io profile and in the tab tokens, add a new one. Then press the button “Show” and “show secret” and copy the text. Run this line of code in R studio. After deployment, Shinnyapps.io provides a URL where you can access your app d- rsconnect::deployApp('path/to/your/folder'): replace it with the path to your app.R file to deploy your application. You need to indicate the path to the folder where the app.R file is stored. In this last step you can obtain many messages of “Error” because of lack of compatibility of versions for specific packages. Update all the packages you need to update and install those that are also required. Be aware that a large app or first-time server setup can take time (30 minutes) and while it is deploying to server, you may not be able to work in R. 13.5 Take home 1.Shiny Components: Shiny core components are ui, server, and the output of the App. For more information about the Shiny app script check: https://shiny.posit.co/r/getstarted/shiny-basics/lesson1/ 2.Customizing Visualization: ggplot2 and plotly. More information about plotly: https://plotly.com/r/?ref=lorcanmason.com More information about DT: https://rstudio.github.io/DT/?ref=lorcanmason.com 3.Interactive Elements : implementing user inputs and outputs(render) to build interactive applications. 4.Deployment: ensure your app is deployed for easy access and sharing. For more information about the dasbhoard: https://rstudio.github.io/shinydashboard/structure.html#background-shiny-and-html 13.6 Final Task For this final assignment you will work with the excel file dataADNIMERGE.xlsx. This data comes from a multicentric study in Alzheimer’s disease and contains longitudinal data for participants with different diagnosis. You need to subset the observations/cases reported at baseline (VISCODE variable) and work with a final dataset including the variables ORIGPROT (batch), DX.bl (diangosis baseline), AGE (age baseline), PTGENDER (Sex), PTEDUCAT (years of education), APOE4 (genotype for APOE-e4, 0=non-carriers, 1=heterozygous for allele e4, 2=homozygous for allele e4), ABETA.bl (amyloid-beta levels at baseline),PTAU.bl (pTau levels at baseline), MMSE.bl (score in the MMSE test memory at baseline). The activity consists on: 1) Creating a report: create a .html file (markdown) and divide the content in two main sections. The first section needs to contain a brief summary of the data of the study (number of participants, proportion women/men, clinical diagnosis of the participants, mean age). You need to report the main summary statistics and explain the main characteristics of the sample. You can check the ADNI webpage in case you want to retrieve more information. The second section relates to the shiny app creation. You need to explain the application that you have created, the main sections, the purpose of the visualization and the main elements you have used to define the user and server interfaces. You need to provide the link to access the shiny dashboard (Shinyapps.io). 2) Creating a shiny dashboard: create a shiny app in R and deploy it to the server. The shiny app needs to contain: One tab where you introduce the main functionality of the app (hint: .md file). One tab including a static table. One tab including a reactive table. One tab including a static plot. One tab including a reactive plot. Submit all the files you have generated in a .zip folder. Remember, it should contain the .html file (report) and all the R files used to create the shiny app (app.R and .md files). The name of your .zip folder should be your surname (e.g. Genius.zip) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
