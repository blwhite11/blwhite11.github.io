# SECTION 7. Introduction to Object-oriented Programming (OOP)

R has a system for object-oriented programming (OOP), which is based on generic functions. In general, OOP is a programming paradigm that uses "objects" and their interactions to design applications and computer programs.

In R, some basic concepts concerning OOP are as follows.

* A class is a description of a thing (i.e., how objects of a certain type look like).

* An object is an instance of a class.

* A generic function is a function that dispatches methods based on the type of object passed to it, such as `plot`, `mean`, `logLik`, `residuals`, `predict`, `summary`, and so on and so forth. 

* A method is the implementation of a generic function for an object of a particular class. For example: 


``` r
methods(plot)
```

```
##  [1] plot.acf*           plot.data.frame*    plot.decomposed.ts*
##  [4] plot.default        plot.dendrogram*    plot.density*      
##  [7] plot.ecdf           plot.factor*        plot.formula*      
## [10] plot.function       plot.hclust*        plot.histogram*    
## [13] plot.HoltWinters*   plot.isoreg*        plot.lm*           
## [16] plot.medpolish*     plot.mlm*           plot.ppr*          
## [19] plot.prcomp*        plot.princomp*      plot.profile*      
## [22] plot.profile.nls*   plot.R6*            plot.raster*       
## [25] plot.spec*          plot.stepfun        plot.stl*          
## [28] plot.table*         plot.ts             plot.tskernel*     
## [31] plot.TukeyHSD*     
## see '?methods' for accessing help and source code
```


## Object and Class in R

In R, everything is treated as an object, and many objects have associated attributes, including a class attribute. The class of an object defines how it is represented in the program. An object can have multiple classes, and you can modify its class using the `class()` function.

The following example shows how to create an object of class `foo`. Note that in this example we use the `attr()` function to set the *class attribute* of the object. The function `attr()` deals with all kinds of attributes an object can have: class, dimensions, names, medatada, etc. 


``` r
x <- 1
attr(x, "class") <- "foo"
x
```

```
## [1] 1
## attr(,"class")
## [1] "foo"
```

Or in one line, we can create and set the attribute `class` by using the `structure()` function:


``` r
x <- structure(1, class = "foo")
x
```

```
## [1] 1
## attr(,"class")
## [1] "foo"
```

Class is stored as an attribute, but it's better to modify it using the `class()` function, since this communicates your intent more clearly:


``` r
class(x) <- "foo"
class(x)
```

```
## [1] "foo"
```

You can use this approach to turn any object into an object of class "foo", whether it makes sense or not. Objects are not limited to a single class, and can have many classes.

While most programming languages have a single class system, R has at least three different class systems. Namely, S3, S4 and more recently R5 (Reference class) systems. We'll explore two of them, the S3 and S4 classes. They have their own features and peculiarities and choosing one over the other is a matter of preference. Below, we give a brief introduction to them.

## S3 Classes

S3 class has no formal, predefined definition. For instance, a list with its class attribute set to some class name is an S3 object. The components of the list become the member variables of the object.

* Example 

Following is a simple example of how an S3 object of class student can be created.


``` r
# create a list with required components
s <- list(name = "John", age = 21, GPA = 3.5)

# name the class appropriately
class(s) <- "student"

# That's it! we now have an object of class "student"
s
```

```
## $name
## [1] "John"
## 
## $age
## [1] 21
## 
## $GPA
## [1] 3.5
## 
## attr(,"class")
## [1] "student"
```

### Methods and Generic Functions in S3 classes: 

Once the classes are defined we probably want to perform some computations on objects, implemented by the generic function. A generic function dispatches methods to objects in such as way that the same function performs different computations depending on the classes of its arguments. 

In the above example, when we simply write the name of the object, its internals get printed. 


``` r
s
```

```
## $name
## [1] "John"
## 
## $age
## [1] 21
## 
## $GPA
## [1] 3.5
## 
## attr(,"class")
## [1] "student"
```

Furthermore, we can use the `print()` function, and the object/objects get printed differently according to the class they belong to.


``` r
print(s)
```

```
## $name
## [1] "John"
## 
## $age
## [1] 21
## 
## $GPA
## [1] 3.5
## 
## attr(,"class")
## [1] "student"
```

The `print()` function is a generic function. Actually, it has a collection of a number of methods. You can check all these methods with `methods(print)`.


``` r
methods(print)
```

There are plenty of generic functions like `print()`. You can list them all with methods(`class="default"`).

Now let us implement a method `print.student()`:


``` r
print.student <- function(obj) {
 cat(obj$name, "\n")
 cat(obj$age, "years old\n")
 cat("GPA:", obj$GPA, "\n")
}
```

Now this method will be called whenever we `print()` an object of class "student".

In S3 system, methods do not belong to object or class, they belong to generic functions. This will work as long as the class of the object is set.


``` r
s
```

```
## John 
## 21 years old
## GPA: 3.5
```

Removing the class attribute will restore as previous


``` r
unclass(s)
```

```
## $name
## [1] "John"
## 
## $age
## [1] 21
## 
## $GPA
## [1] 3.5
```

It is also possible to make our own generic function like `print()` or `plot()`. Let us first look at how these functions are implemented and compare them to a non-generic function such as `glm()`.


``` r
print
```

```
## function (x, ...) 
## UseMethod("print")
## <bytecode: 0x000002663f22c550>
## <environment: namespace:base>
```

``` r
glm
```

```
## function (formula, family = gaussian, data, weights, subset, 
##     na.action, start = NULL, etastart, mustart, offset, control = list(...), 
##     model = TRUE, method = "glm.fit", x = FALSE, y = TRUE, singular.ok = TRUE, 
##     contrasts = NULL, ...) 
## {
##     cal <- match.call()
##     if (is.character(family)) 
##         family <- get(family, mode = "function", envir = parent.frame())
##     if (is.function(family)) 
##         family <- family()
##     if (is.null(family$family)) {
##         print(family)
##         stop("'family' not recognized")
##     }
##     if (missing(data)) 
##         data <- environment(formula)
##     mf <- match.call(expand.dots = FALSE)
##     m <- match(c("formula", "data", "subset", "weights", "na.action", 
##         "etastart", "mustart", "offset"), names(mf), 0L)
##     mf <- mf[c(1L, m)]
##     mf$drop.unused.levels <- TRUE
##     mf[[1L]] <- quote(stats::model.frame)
##     mf <- eval(mf, parent.frame())
##     if (identical(method, "model.frame")) 
##         return(mf)
##     if (!is.character(method) && !is.function(method)) 
##         stop("invalid 'method' argument")
##     if (identical(method, "glm.fit")) 
##         control <- do.call("glm.control", control)
##     mt <- attr(mf, "terms")
##     Y <- model.response(mf, "any")
##     if (length(dim(Y)) == 1L) {
##         nm <- rownames(Y)
##         dim(Y) <- NULL
##         if (!is.null(nm)) 
##             names(Y) <- nm
##     }
##     X <- if (!is.empty.model(mt)) 
##         model.matrix(mt, mf, contrasts)
##     else matrix(, NROW(Y), 0L)
##     weights <- as.vector(model.weights(mf))
##     if (!is.null(weights) && !is.numeric(weights)) 
##         stop("'weights' must be a numeric vector")
##     if (!is.null(weights) && any(weights < 0)) 
##         stop("negative weights not allowed")
##     offset <- as.vector(model.offset(mf))
##     if (!is.null(offset)) {
##         if (length(offset) != NROW(Y)) 
##             stop(gettextf("number of offsets is %d should equal %d (number of observations)", 
##                 length(offset), NROW(Y)), domain = NA)
##     }
##     mustart <- model.extract(mf, "mustart")
##     etastart <- model.extract(mf, "etastart")
##     fit <- eval(call(if (is.function(method)) "method" else method, 
##         x = X, y = Y, weights = weights, start = start, etastart = etastart, 
##         mustart = mustart, offset = offset, family = family, 
##         control = control, intercept = attr(mt, "intercept") > 
##             0L, singular.ok = singular.ok))
##     if (length(offset) && attr(mt, "intercept") > 0L) {
##         fit2 <- eval(call(if (is.function(method)) "method" else method, 
##             x = X[, "(Intercept)", drop = FALSE], y = Y, mustart = fit$fitted.values, 
##             weights = weights, offset = offset, family = family, 
##             control = control, intercept = TRUE))
##         if (!fit2$converged) 
##             warning("fitting to calculate the null deviance did not converge -- increase 'maxit'?")
##         fit$null.deviance <- fit2$deviance
##     }
##     if (model) 
##         fit$model <- mf
##     fit$na.action <- attr(mf, "na.action")
##     if (x) 
##         fit$x <- X
##     if (!y) 
##         fit$y <- NULL
##     structure(c(fit, list(call = cal, formula = formula, terms = mt, 
##         data = data, offset = offset, control = control, method = method, 
##         contrasts = attr(X, "contrasts"), xlevels = .getXlevels(mt, 
##             mf))), class = c(fit$class, c("glm", "lm")))
## }
## <bytecode: 0x00000266426a5af8>
## <environment: namespace:stats>
```

For the sake of example, we make a new generic function called grade.


``` r
grade <- function(obj) {
 UseMethod("grade")
}
```

A generic function is useless without any method. Let us implement the default method.


``` r
grade.default <- function(obj) {
 cat("This is a generic function\n")
}
```

Now let us make method for our class "student".


``` r
grade.student <- function(obj) {
 cat("Your grade is", obj$GPA, "\n")
}
```

In this way, we implemented a generic function called grade and later a method for our class.


``` r
grade(s)
```

```
## Your grade is 3.5
```

Define a generic function is easy. All we need to do is to define a function with argument `x` (which is an object), and the body of the function is simply `UseMethod(generic)`, where generic is character string.
In general, the syntax of UseMethod is: `UseMethod(generic, object)`

## S4 classes 

S4 classes in R provide a more formal and structured approach to object-oriented programming. S4 classes are explicitly defined using the `setClass` function, specifying slots (attributes) and their types.


``` r
setClass("student", slots = c(name = "character", age = "numeric", GPA = "numeric"), prototype = list(name = NA_character_, age = NA_real_, GPA=NA_real_))
```

In this case, the class "student" has three slots with their specific data types. The argument prototype will define the default value for each slot when a new student object is created without specifying all the slots. For instance: 


``` r
new("student", name = "Vero", GPA = 3.9)
```

```
## An object of class "student"
## Slot "name":
## [1] "Vero"
## 
## Slot "age":
## [1] NA
## 
## Slot "GPA":
## [1] 3.9
```

### Methods and Generic Functions in S4 classes: 

In S4, a generic function is explicitly defined using the `setGeneric` function.


``` r
setGeneric("grade", function(object) standardGeneric("grade"))
```

```
## [1] "grade"
```

Methods in S4 are explicitly defined using the `setMethod ` function for a specific generic function and class.


``` r
setMethod("grade", signature = "student", function(object) {
  cat("Your grade is", object@GPA, "\n")
})
```

* Example: Let's create an object of class "student"


``` r
john <- new("student", name = "John", age = 25, GPA = 3.5)

grade(john)
```

```
## Your grade is 3.5
```

Let's add another method for the grade function, this time for a different class, say "employee".


``` r
setClass("employee", slots = c(name = "character", age = "numeric", salary = "numeric"))
```

Create an object of class "employee": 


``` r
alice <- new("employee", name = "Alice", age = 30, salary = 50000)
```

Define a method for the generic function "grade" and class "employee":


``` r
setMethod("grade", signature = "employee", function(object) {
  cat("Employee", object@name, "has an excellent work record.\n")
})
```

Call the generic function with objects of different classes:


``` r
grade(john)  
```

```
## Your grade is 3.5
```

``` r
grade(alice) 
```

```
## Employee Alice has an excellent work record.
```


![](logouvic.png)
